<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deckbuilding Tool</title>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="firebase-init.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <!-- JSZip for handling zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .card-image-sm { width: 100px; height: 140px; }
        .card-preview-img {
            width: 100px;
            height: 140px;
            object-fit: cover;
            border-radius: 0.375rem; /* rounded-md */
        }
        .tab-button.active {
            background-color: #4f46e5;
            color: white;
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .deck-item.commander {
            color: #a5b4fc;
            font-weight: bold;
        }
        /* NEW: Styles for the detailed card pop-out */
        #card-popout {
            position: fixed;
            width: 280px;
            background-color: #1f2937;
            border: 1px solid #4f46e5;
            z-index: 9000;
            color: white;
            display: none; /* This keeps it hidden initially */
            pointer-events: none; /* This is crucial so the pop-out doesn't interfere with mouse events */
        }
        #popout-img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            background-color: #374151;
        }
        #popout-flavour {
            font-style: italic;
            border-top: 1px solid #4b5563;
            padding-top: 8px;
            margin-top: 8px;
        }
        /* NEW: Styles for color pips */
        .color-pip {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 3px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .pip-W { background-color: #f9faf4; }
        .pip-U { background-color: #aae0fa; }
        .pip-B { background-color: #cbc2bf; }
        .pip-R { background-color: #f9aa8f; }
        .pip-G { background-color: #9bd3ae; }
        .pip-M { background: linear-gradient(135deg, #f9aa8f 25%, #aae0fa 25%, #aae0fa 50%, #9bd3ae 50%, #9bd3ae 75%, #cbc2bf 75%); }
        .pip-C { background-color: #cec8c3; }
    </style>
</head>
<body class="bg-gray-800 text-white p-4 md:p-8">

    <h1 class="text-3xl font-bold mb-6 text-indigo-400">Project Card Arena: Deckbuilder</h1>

    <div class="mb-4 border-b border-gray-700">
        <nav class="flex space-x-4" aria-label="Tabs">
            <button id="tab-btn-create" class="tab-button active px-3 py-2 font-medium text-sm rounded-t-lg">Create/Edit Card</button>
            <button id="tab-btn-import" class="tab-button px-3 py-2 font-medium text-sm rounded-t-lg">Bulk Import</button>
            <button id="tab-btn-scryfall" class="tab-button px-3 py-2 font-medium text-sm rounded-t-lg">Scryfall Import</button>
        </nav>
    </div>

    <div>
        <!-- Create/Edit Tab -->
        <div id="tab-content-create" class="tab-content active">
             <div class="bg-gray-900 p-6 rounded-lg shadow-lg">
                <h2 id="form-title" class="text-xl font-semibold mb-4">Create New Card</h2>
                <form id="addCardForm">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label for="cardName" class="block text-sm font-medium text-gray-400">Card Name</label>
                            <input type="text" id="cardName" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                        <div>
                            <label for="cardImage" class="block text-sm font-medium text-gray-400">Card Image (Optional)</label>
                            <input type="file" id="cardImage" accept="image/*" class="mt-1 block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-700">
                        </div>
                        <div>
                            <label for="cardType" class="block text-sm font-medium text-gray-400">Card Type</label>
                            <select id="cardType" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                <option>Creature</option>
                                <option>Planeswalker</option>
                                <option>Sorcery</option>
                                <option>Instant</option>
                                <option>Enchantment</option>
                                <option>Artifact</option>
                                <option>Land</option>
                            </select>
                        </div>
                        <div>
                            <label for="cardSubtype" class="block text-sm font-medium text-gray-400">Card Subtype (e.g. Human Soldier)</label>
                            <input type="text" id="cardSubtype" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                         <div class="col-span-1 md:col-span-2">
                            <label for="manaCost" class="block text-sm font-medium text-gray-400">Mana Cost (e.g., {2}{W}{U})</label>
                            <input type="text" id="manaCost" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                        <div class="col-span-1 md:col-span-2">
                            <label for="cardText" class="block text-sm font-medium text-gray-400">Text Box</label>
                            <textarea id="cardText" rows="3" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                        </div>
                        <div class="col-span-1 md:col-span-2">
                            <label for="cardFlavourText" class="block text-sm font-medium text-gray-400">Flavour Text</label>
                            <textarea id="cardFlavourText" rows="2" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                        </div>
                        <div id="creatureFields" class="hidden col-span-1 md:col-span-2 grid grid-cols-2 gap-4">
                            <div>
                                <label for="power" class="block text-sm font-medium text-gray-400">Power</label>
                                <input type="number" id="power" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                            </div>
                            <div>
                                <label for="toughness" class="block text-sm font-medium text-gray-400">Toughness</label>
                                <input type="number" id="toughness" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                            </div>
                        </div>
                        <div id="planeswalkerFields" class="hidden col-span-1">
                            <label for="loyalty" class="block text-sm font-medium text-gray-400">Starting Loyalty</label>
                            <input type="number" id="loyalty" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                    </div>
                </form>
                <div id="message-area" class="hidden my-4 p-3 rounded-lg"></div>
                <div class="mt-4 flex gap-4">
                    <button id="saveCardBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">Add to Collection</button>
                    <button id="cancelEditBtn" class="hidden w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Cancel Edit</button>
                </div>
            </div>
        </div>
        <!-- Bulk Import (CSV) Tab -->
        <div id="tab-content-import" class="tab-content">
            <div class="bg-gray-900 p-6 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold mb-4">Bulk Import Cards via CSV</h2>
                <div class="space-y-6">
                    <div>
                        <h3 class="text-lg font-medium text-indigo-400">Instructions</h3>
                        <ul class="list-disc list-inside text-gray-400 text-sm mt-2 space-y-1">
                            <li>**Mandatory Columns:** `Card Name`, `Card Type`</li>
                            <li>If `Card Type` is "Creature", `Power` and `Toughness` are also mandatory.</li>
                            <li>**Optional Columns:** `Card Subtype`, `Mana Cost`, `Text Box`, `Flavour Text`, `Image Filename`, `Commander?` (Y)</li>
                            <li>If `Image Filename` is blank, a placeholder will be used.</li>
                        </ul>
                    </div>
                    <div>
                        <h3 class="text-lg font-medium text-indigo-400">Step 1: Upload Images (.zip file)</h3>
                        <p class="text-gray-400 text-sm mt-1">Select a single .zip file containing all the image files referenced in your CSV.</p>
                        <input type="file" id="bulkImageUpload" accept=".zip" class="mt-2 block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-700">
                        <div id="image-upload-progress" class="mt-2 text-sm text-gray-400"></div>
                    </div>
                    <div>
                        <h3 class="text-lg font-medium text-indigo-400">Step 2: Upload CSV File</h3>
                        <p class="text-gray-400 text-sm mt-1">CSV must have a header row with the column names listed above.</p>
                        <input type="file" id="csvFile" accept=".csv" class="mt-2 block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-700">
                    </div>
                    <div id="import-message-area" class="hidden my-4 p-3 rounded-lg"></div>
                    <button id="importCsvBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Import Cards from CSV</button>
                </div>
            </div>
        </div>
        <!-- Scryfall Import Tab -->
        <div id="tab-content-scryfall" class="tab-content">
            <div class="bg-gray-900 p-6 rounded-lg shadow-lg">
                <h1 class="text-2xl font-bold mb-2 text-indigo-400">Scryfall Bulk Importer</h1>
                <p class="text-gray-400 mb-6">Paste a list of card names, one per line, to fetch their data from the Scryfall API.</p>
                <!-- Input Section -->
                <div class="mb-4">
                    <label for="cardListInput" class="block text-lg font-medium text-gray-300">Card Names</label>
                    <textarea id="cardListInput" rows="10" class="mt-2 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="Sol Ring&#10;Swords to Plowshares&#10;Rhystic Study&#10;..."></textarea>
                </div>
                <button id="fetchBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg text-lg transition-transform transform hover:scale-105 shadow-md">
                    Fetch Card Data
                </button>
                <!-- Progress and Status Section -->
                <div id="statusArea" class="mt-4 text-center"></div>
                <!-- Results Section -->
                <div id="resultsArea" class="mt-6 hidden">
                    <h2 class="text-xl font-semibold mb-4 text-green-400">Results</h2>
                    <div id="foundCardsSection">
                        <h3 class="text-lg font-medium text-gray-300">Found Cards (<span id="foundCount">0</span>)</h3>
                        <div id="foundCardsGrid" class="mt-4 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                            <!-- Card previews will be injected here -->
                        </div>
                    </div>
                    <div id="notFoundSection" class="mt-6">
                        <h3 class="text-lg font-medium text-red-400">Not Found (<span id="notFoundCount">0</span>)</h3>
                        <ul id="notFoundList" class="mt-2 list-disc list-inside text-gray-400 text-sm">
                            <!-- Not found card names will be injected here -->
                        </ul>
                    </div>
                    <div class="mt-6 border-t border-gray-700 pt-6">
                         <h3 class="text-lg font-medium text-gray-300">Save to Collection or Export</h3>
                         <p class="text-gray-400 text-sm mb-4">You can add these cards directly to your collection or download a CSV file.</p>
                         <div class="flex flex-col sm:flex-row gap-4">
                            <button id="addDirectlyBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md" disabled>
                                Add to My Collection
                            </button>
                            <button id="downloadCsvBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md" disabled>
                                Download as CSV
                           </button>
                         </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="mt-8 grid grid-cols-1 lg:grid-cols-3 gap-8">
        <div class="lg:col-span-2">
            <h2 class="text-2xl font-semibold mb-4">My Card Collection</h2>
            
            <!-- Filter and Sort Controls -->
            <div class="bg-gray-900 p-4 rounded-lg mb-4 flex flex-wrap gap-4 items-center">
                <input type="text" id="filterName" placeholder="Filter by name..." class="flex-grow bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 min-w-[200px]">
                <select id="filterType" class="bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    <option value="">All Types</option>
                    <option>Creature</option>
                    <option>Planeswalker</option>
                    <option>Sorcery</option>
                    <option>Instant</option>
                    <option>Enchantment</option>
                    <option>Artifact</option>
                    <option>Land</option>
                </select>
                <select id="filterColor" class="bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    <option value="">All Colors</option>
                    <option value="W">White</option>
                    <option value="U">Blue</option>
                    <option value="B">Black</option>
                    <option value="R">Red</option>
                    <option value="G">Green</option>
                    <option value="C">Colorless</option>
                    <option value="M">Multi-Color</option>
                </select>
                <select id="filterSource" class="bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    <option value="">All Sources</option>
                    <option value="custom">User-Created</option>
                    <option value="scryfall">Scryfall</option>
                </select>
                <select id="filterSort" class="bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    <option value="name_asc">Sort: Name (A-Z)</option>
                    <option value="name_desc">Sort: Name (Z-A)</option>
                </select>
            </div>

            <div id="cardCollection" class="bg-gray-900 p-4 rounded-lg min-h-[300px] grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4"></div>
        </div>
        <div>
            <div class="bg-gray-900 p-4 rounded-lg mb-8">
                <h2 class="text-2xl font-semibold mb-4">Assemble Deck</h2>
                <div class="flex items-center mb-4">
                    <input type="text" id="deckName" placeholder="Deck Name" class="block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    <button id="saveDeck" class="ml-2 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Save</button>
                </div>
                <div class="mb-2">
                    <h3 class="text-lg font-semibold text-indigo-400">Commander(s)</h3>
                    <div id="commanderList" class="min-h-[30px] bg-gray-800 p-2 rounded-md text-sm">
                        <p class="text-gray-500">Right-click a card in the deck below to set as commander.</p>
                    </div>
                </div>
                <h3 class="text-lg font-semibold text-gray-300">Main Deck (<span id="deckCount">0</span>)</h3>
                <div id="deckList" class="min-h-[200px] bg-gray-800 p-2 rounded-md"></div>
            </div>
            <div class="bg-gray-900 p-4 rounded-lg">
                <h2 class="text-2xl font-semibold mb-4">Saved Decks</h2>
                <div id="savedDecks" class="space-y-2"></div>
            </div>
        </div>
    </div>
    
    <div id="lobby-section" class="mt-8 bg-gray-900 p-6 rounded-lg shadow-lg">
        <h2 class="text-2xl font-semibold mb-4 text-green-400">Game Lobby</h2>
        
        <div id="lobby-controls">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="playerName" class="block text-sm font-medium text-gray-400">Your Name</label>
                    <input type="text" id="playerName" placeholder="Enter your name..." class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div>
                    <label for="gameMode" class="block text-sm font-medium text-gray-400">Game Mode</label>
                    <select id="gameMode" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="40">EDH / Commander (40 Life)</option>
                        <option value="20">Standard / Modern (20 Life)</option>
                    </select>
                </div>
            </div>

            <p class="text-gray-400 mb-4">Assemble or load a deck, then start or join a game.</p>
            
            <div class="space-y-4">
                <button id="createGameBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg text-lg">Create New Game</button>
                <div class="relative">
                    <div class="absolute inset-0 flex items-center" aria-hidden="true"><div class="w-full border-t border-gray-700"></div></div>
                    <div class="relative flex justify-center"><span class="bg-gray-900 px-2 text-sm text-gray-500">OR</span></div>
                </div>
                <div class="flex gap-4">
                    <input type="text" id="joinGameIdInput" placeholder="Enter Game ID..." class="block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    <button id="joinGameBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Join Game</button>
                </div>
            </div>
        </div>

        <div id="game-created-section" class="hidden text-center">
            <h3 class="text-xl font-semibold text-green-400">Game Created!</h3>
            <p class="text-gray-400 mt-2">Share this link with your friends to invite them:</p>
            <div class="mt-4 flex items-center bg-gray-800 p-2 rounded-lg">
                <input type="text" id="inviteLinkInput" readonly class="w-full bg-transparent text-gray-300 focus:outline-none">
                <button id="copyLinkBtn" class="ml-4 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Copy</button>
            </div>
            <button id="enterGameBtn" class="mt-6 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg text-lg">Enter Game</button>
        </div>

    </div>

    <!-- updated: Pop-out element for card previews -->
    <div id="card-popout" class="rounded-lg shadow-2xl p-2 space-y-2">
        <div class="flex justify-between items-start">
            <span id="popout-name" class="font-bold"></span>
            <span id="popout-cost" class="text-sm flex gap-1 items-center"></span>
        </div>
        <img id="popout-img" src="" alt="Card Image" class="rounded-md">
        <div class="flex justify-between items-center text-sm">
            <span id="popout-type" class="font-semibold"></span>
            <span id="popout-pt" class="font-bold"></span>
        </div>
        <div id="popout-text" class="text-xs bg-gray-800 p-2 rounded-md whitespace-pre-wrap max-h-40 overflow-y-auto"></div>
        <div id="popout-flavour" class="text-xs text-gray-400 italic"></div>
    </div>

    <script>
        // --- DOM Elements (Main App) ---
        const cardCollectionEl = document.getElementById('cardCollection');
        const deckListEl = document.getElementById('deckList');
        const commanderListEl = document.getElementById('commanderList');
        const deckCountEl = document.getElementById('deckCount');
        const deckNameEl = document.getElementById('deckName');
        const saveDeckBtn = document.getElementById('saveDeck');
        const savedDecksEl = document.getElementById('savedDecks');
        const saveCardBtn = document.getElementById('saveCardBtn');
        const cancelEditBtn = document.getElementById('cancelEditBtn');
        const formTitleEl = document.getElementById('form-title');
        const cardTypeSelect = document.getElementById('cardType');
        const creatureFields = document.getElementById('creatureFields');
        const planeswalkerFields = document.getElementById('planeswalkerFields');
        const createGameBtn = document.getElementById('createGameBtn');
        const joinGameBtn = document.getElementById('joinGameBtn');
        const joinGameIdInput = document.getElementById('joinGameIdInput');
        const messageAreaEl = document.getElementById('message-area');
        const importCsvBtn = document.getElementById('importCsvBtn'); 
        const imageUploadProgressEl = document.getElementById('image-upload-progress');
        const lobbySectionEl = document.getElementById('lobby-section');
        const lobbyControlsEl = document.getElementById('lobby-controls');
        const gameCreatedSectionEl = document.getElementById('game-created-section');
        const inviteLinkInputEl = document.getElementById('inviteLinkInput');
        const copyLinkBtn = document.getElementById('copyLinkBtn');
        const enterGameBtn = document.getElementById('enterGameBtn');
        
        // --- DOM Elements (Scryfall Importer) ---
        const cardListInput = document.getElementById('cardListInput');
        const fetchBtn = document.getElementById('fetchBtn');
        const statusArea = document.getElementById('statusArea');
        const resultsArea = document.getElementById('resultsArea');
        const foundCardsGrid = document.getElementById('foundCardsGrid');
        const notFoundList = document.getElementById('notFoundList');
        const foundCount = document.getElementById('foundCount');
        const notFoundCount = document.getElementById('notFoundCount');
        const downloadCsvBtn = document.getElementById('downloadCsvBtn');
        const addDirectlyBtn = document.getElementById('addDirectlyBtn');

        // --- DOM Elements (Collection Management) ---
        const filterNameInput = document.getElementById('filterName');
        const filterTypeSelect = document.getElementById('filterType');
        const filterSortSelect = document.getElementById('filterSort');
        const filterColorSelect = document.getElementById('filterColor');
        const filterSourceSelect = document.getElementById('filterSource');
        
        // --- DOM Elements (Pop-out) ---
        const cardPopoutEl = document.getElementById('card-popout');
        const popoutNameEl = document.getElementById('popout-name');
        const popoutCostEl = document.getElementById('popout-cost');
        const popoutImgEl = document.getElementById('popout-img');
        const popoutTypeEl = document.getElementById('popout-type');
        const popoutPtEl = document.getElementById('popout-pt');
        const popoutTextEl = document.getElementById('popout-text');
        const popoutFlavourEl = document.getElementById('popout-flavour');

        // --- Global State ---
        let allCards = [];
        let currentDeck = [];
        let commanders = [];
        let uploadedImageMap = new Map();
        let myUserId = null;
        let editingCardId = null; 
        let csvFileToProcess = null;
        let fetchedCardsData = []; // To store the processed card data for CSV/direct export

        // --- TABS & FORM LOGIC ---
        const tabBtns = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                tabBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const targetId = btn.id.replace('btn', 'content');
                tabContents.forEach(content => {
                    content.classList.remove('active');
                    if (content.id === targetId) {
                        content.classList.add('active');
                    }
                });
            });
        });
        cardTypeSelect.addEventListener('change', () => {
            const selectedType = cardTypeSelect.value;
            creatureFields.classList.toggle('hidden', selectedType !== 'Creature');
            planeswalkerFields.classList.toggle('hidden', selectedType !== 'Planeswalker');
        });

        // --- MESSAGE FUNCTIONS ---
        const showMessage = (message, isError = true, area = 'create') => {
            const areaMap = {
                create: document.getElementById('message-area'),
                import: document.getElementById('import-message-area'),
                scryfall: document.getElementById('statusArea')
            };
            const targetArea = areaMap[area];
            if (!targetArea) return; 

            targetArea.innerHTML = `<p>${message}</p>`; // Use innerHTML to render as a paragraph
            targetArea.classList.remove('hidden');
            if (isError) {
                targetArea.firstChild.className = 'text-red-400';
            } else {
                targetArea.firstChild.className = 'text-green-400';
            }
        };
        const hideMessage = (area = 'create') => {
            const areaMap = {
                create: document.getElementById('message-area'),
                import: document.getElementById('import-message-area'),
                scryfall: document.getElementById('statusArea')
            };
            const targetArea = areaMap[area];
            if(targetArea) targetArea.classList.add('hidden');
        };

        // --- RENDER FUNCTIONS ---
        // NEW (Corrected): This function parses a mana cost string and returns HTML for the symbols.
        const parseManaCost = (cost, symbolClass = '') => {
            if (!cost) return '';
            
            const symbolRegex = /\{(.+?)\}/g;
            // This replaces each {symbol} with a direct link to Scryfall's high-quality SVG image for that symbol.
            return cost.replace(symbolRegex, (match, symbol) => {
                const sanitizedSymbol = symbol.replace('/', ''); // Handles symbols like {W/P}
                return `<img src="https://svgs.scryfall.io/card-symbols/${sanitizedSymbol.toUpperCase()}.svg" alt="${symbol}" class="${symbolClass}" style="width: 16px; height: 16px; vertical-align: middle;">`;
            });
        };

    // NEW: Functions to control the card pop-out
        function showCardPopout(event, cardData) {
            if (cardData) {
                // Populate the popout elements with data
                popoutNameEl.textContent = cardData.name;
                popoutCostEl.innerHTML = parseManaCost(cardData.cost, 'mana-symbol-cost');
                popoutImgEl.src = cardData.imageUrl || 'https://placehold.co/280x200/2d3748/e2e8f0?text=No+Image';
                
                let typeLine = cardData.type || '';
                if (cardData.subtype) {
                    typeLine += ` — ${cardData.subtype}`;
                }
                popoutTypeEl.textContent = typeLine;
                
                popoutTextEl.innerHTML = (cardData.text || '').replace(/\n/g, '<br>');
                
                if (cardData.flavourText) {
                    popoutFlavourEl.innerHTML = (cardData.flavourText || '').replace(/\n/g, '<br>');
                    popoutFlavourEl.style.display = 'block';
                } else {
                    popoutFlavourEl.style.display = 'none';
                }
                
                if (cardData.power && cardData.toughness) {
                    popoutPtEl.textContent = `${cardData.power}/${cardData.toughness}`;
                } else if (cardData.loyalty) {
                    popoutPtEl.textContent = `Loyalty: ${cardData.loyalty}`;
                } else {
                    popoutPtEl.textContent = '';
                }

                cardPopoutEl.style.display = 'block';
            }
        }

        function hideCardPopout() {
            cardPopoutEl.style.display = 'none';
        }

        function moveCardPopout(event) {
            const popoutHeight = cardPopoutEl.offsetHeight;
            const popoutWidth = cardPopoutEl.offsetWidth;
            const buffer = 20;

            let top = event.clientY + buffer;
            let left = event.clientX + buffer;

            // Logic to keep the popout on the screen
            if (top + popoutHeight > window.innerHeight) {
                top = event.clientY - popoutHeight - buffer;
            }
            if (top < 0) {
                top = buffer;
            }
            if (left + popoutWidth > window.innerWidth) {
                left = event.clientX - popoutWidth - buffer;
            }

            cardPopoutEl.style.left = `${left}px`;
            cardPopoutEl.style.top = `${top}px`;
        }
        const renderCard = (card, container) => {
            const cardWrapper = document.createElement('div');
            cardWrapper.className = 'p-2 bg-gray-700 rounded-lg flex flex-col items-center justify-between';
            
            const clickableArea = document.createElement('div');
            clickableArea.className = 'cursor-pointer text-center';
            
            const img = document.createElement('img');
            img.src = card.imageUrl || 'https://placehold.co/100x140/2d3748/e2e8f0?text=No+Image';
            img.alt = card.name;
            img.className = 'card-image-sm object-cover rounded-md mb-2';

            const name = document.createElement('span');
            name.textContent = card.name;
            name.className = 'text-xs text-center font-semibold';

            clickableArea.appendChild(img);
            clickableArea.appendChild(name);
            clickableArea.addEventListener('click', () => addCardToDeck(card));
            
            // NEW: Card info section
            const infoDiv = document.createElement('div');
            infoDiv.className = 'text-center my-2 w-full';

            const typeText = document.createElement('p');
            typeText.textContent = card.type;
            typeText.className = 'text-xs text-gray-400 truncate';
            infoDiv.appendChild(typeText);

            const colorPips = document.createElement('div');
            colorPips.className = 'flex justify-center items-center mt-1 h-4'; // h-4 gives it a fixed height
            
            colorPips.innerHTML = parseManaCost(card.cost, 'mana-symbol');
            infoDiv.appendChild(colorPips);

            const buttonBar = document.createElement('div');
            buttonBar.className = 'flex justify-around w-full mt-2';
            
            const editBtn = document.createElement('button');
            editBtn.textContent = 'Edit';
            editBtn.className = 'text-xs bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded';
            editBtn.onclick = () => populateFormForEdit(card.id);

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'Delete';
            deleteBtn.className = 'text-xs bg-red-600 hover:bg-red-700 px-2 py-1 rounded';
            deleteBtn.onclick = () => deleteCard(card.id);

            buttonBar.appendChild(editBtn);
            buttonBar.appendChild(deleteBtn);

            cardWrapper.appendChild(clickableArea);
            cardWrapper.appendChild(infoDiv);
            cardWrapper.appendChild(buttonBar);

            // modified: Event listeners for the pop-out
            cardWrapper.addEventListener('mouseenter', (e) => showCardPopout(e, card));
            cardWrapper.addEventListener('mouseleave', hideCardPopout);
            cardWrapper.addEventListener('mousemove', moveCardPopout);
            container.appendChild(cardWrapper);
            };

        /**
         * Helper function to determine a card's color identity from its mana cost.
         */
        const getCardColorIdentity = (manaCost) => {
            if (!manaCost) return ['C']; // Colorless if no cost
            const colors = new Set();
            if (manaCost.includes('W')) colors.add('W');
            if (manaCost.includes('U')) colors.add('U');
            if (manaCost.includes('B')) colors.add('B');
            if (manaCost.includes('R')) colors.add('R');
            if (manaCost.includes('G')) colors.add('G');
            
            if (colors.size === 0) return ['C']; // Also colorless (e.g., artifacts, lands)
            if (colors.size > 1) return ['M', ...Array.from(colors)]; // Return M for multi-color, plus individual colors
            return Array.from(colors);
        };

        const renderFilteredCollection = () => {
            let filteredCards = [...allCards]; // Start with a copy of all cards

            // 1. Filter by name (case-insensitive)
            const nameQuery = filterNameInput.value.toLowerCase();
            if (nameQuery) {
                filteredCards = filteredCards.filter(card => card.name.toLowerCase().includes(nameQuery));
            }

            // 2. Filter by card type
            const typeQuery = filterTypeSelect.value;
            if (typeQuery) {
                filteredCards = filteredCards.filter(card => card.type === typeQuery);
            }

            // 3. Filter by color identity
            const colorQuery = filterColorSelect.value;
            if (colorQuery) {
                filteredCards = filteredCards.filter(card => {
                    const identity = getCardColorIdentity(card.cost);
                    return identity.includes(colorQuery);
                });
            }

            // 4. Filter by source
            const sourceQuery = filterSourceSelect.value;
            if (sourceQuery) {
                filteredCards = filteredCards.filter(card => card.source === sourceQuery);
            }

            // 5. Sort the results
            const sortQuery = filterSortSelect.value;
            if (sortQuery === 'name_asc') {
                filteredCards.sort((a, b) => a.name.localeCompare(b.name));
            } else if (sortQuery === 'name_desc') {
                filteredCards.sort((a, b) => b.name.localeCompare(a.name));
            }

            cardCollectionEl.innerHTML = '';
            filteredCards.forEach(card => renderCard(card, cardCollectionEl));
        };

        const renderCollection = () => {
            renderFilteredCollection();
        };
        
        const renderDeckList = () => {
            deckListEl.innerHTML = '';
            const mainDeck = currentDeck.filter(card => !commanders.some(c => c.id === card.id));
            deckCountEl.textContent = mainDeck.length;

            const cardCounts = mainDeck.reduce((acc, card) => {
                acc[card.id] = (acc[card.id] || 0) + 1;
                return acc;
            }, {});

            Object.keys(cardCounts).forEach(cardId => {
                const card = allCards.find(c => c.id == cardId);
                if (card) {
                    const deckItem = document.createElement('div');
                    deckItem.className = 'deck-item text-sm p-1 flex justify-between items-center';
                    deckItem.textContent = `${cardCounts[cardId]}x ${card.name}`;
                    
                    deckItem.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        setCommander(card);
                    });

                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = 'x';
                    removeBtn.className = 'ml-2 text-red-400 hover:text-red-200';
                    removeBtn.onclick = () => removeCardFromDeck(card.id);
                    deckItem.appendChild(removeBtn);
                    deckListEl.appendChild(deckItem);
                }
            });
            renderCommanders();
        };

        const renderCommanders = () => {
            commanderListEl.innerHTML = '';
            if (commanders.length === 0) {
                commanderListEl.innerHTML = '<p class="text-gray-500">Right-click a card in the deck below to set as commander.</p>';
            } else {
                commanders.forEach(card => {
                    const commanderItem = document.createElement('div');
                    commanderItem.className = 'deck-item commander p-1 flex justify-between items-center';
                    commanderItem.textContent = `⭐ ${card.name}`;
                    
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = 'x';
                    removeBtn.className = 'ml-2 text-red-400 hover:text-red-200';
                    removeBtn.onclick = () => unsetCommander(card.id);
                    commanderItem.appendChild(removeBtn);
                    commanderListEl.appendChild(commanderItem);
                });
            }
        };
        
        const renderSavedDecks = () => {
            savedDecksEl.innerHTML = '';
            const decks = getSavedDecks();
            for (const name in decks) {
                const deckContainer = document.createElement('div');
                deckContainer.className = 'flex justify-between items-center bg-gray-800 p-2 rounded';
                
                const loadBtn = document.createElement('button');
                loadBtn.textContent = name;
                loadBtn.className = 'text-left flex-grow hover:text-indigo-400';
                loadBtn.onclick = () => loadDeck(name);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.className = 'bg-red-600 text-xs px-2 py-1 rounded';
                deleteBtn.onclick = () => deleteDeck(name);

                deckContainer.appendChild(loadBtn);
                deckContainer.appendChild(deleteBtn);
                savedDecksEl.appendChild(deckContainer);
            }
        };

        // --- CORE LOGIC (Firebase) ---
        async function loadAllCardsFromFirebase() {
            try {
                const snapshot = await db.collection('cards').get();
                allCards = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderCollection();
                console.log(`Loaded ${allCards.length} cards from Firestore.`);
            } catch (error) {
                console.error("Error loading cards from Firestore: ", error);
                showMessage("Could not load card collection from the cloud.");
            }
        }

        const isBasicLand = (cardName, cardType) => {
            if (cardType !== 'Land') return false;
            const basicLandNames = ['plains', 'island', 'swamp', 'mountain', 'forest'];
            const lowerCaseName = cardName.toLowerCase();
            return basicLandNames.some(name => lowerCaseName === name || lowerCaseName === `snow-covered ${name}`);
        };

        const handleSaveCard = async () => {
            hideMessage();
            saveCardBtn.disabled = true;

            const name = document.getElementById('cardName').value.trim();
            const type = document.getElementById('cardType').value;
            const imageFile = document.getElementById('cardImage').files[0];
            const power = document.getElementById('power').value;
            const toughness = document.getElementById('toughness').value;

            if (!name || !type) {
                showMessage('Card Name and Type are required.');
                saveCardBtn.disabled = false;
                return;
            }
            if (type === 'Creature' && (!power || !toughness)) {
                showMessage('Power and Toughness are required for Creatures.');
                saveCardBtn.disabled = false;
                return;
            }

            if (!editingCardId && !isBasicLand(name, type)) {
                const isDuplicate = allCards.some(card => card.name.toLowerCase() === name.toLowerCase());
                if (isDuplicate) {
                    showMessage(`A card named "${name}" already exists in your collection. Basic lands are an exception.`);
                    saveCardBtn.disabled = false;
                    return;
                }
            }


            saveCardBtn.textContent = "Saving...";
            
            try {
                let imageUrl;
                const cardDataToSave = {
                    name, type,
                    source: 'custom',
                    subtype: document.getElementById('cardSubtype').value.trim(),
                    cost: document.getElementById('manaCost').value.trim(),
                    text: document.getElementById('cardText').value.trim(),
                    flavourText: document.getElementById('cardFlavourText').value.trim(),
                    power: type === 'Creature' ? power : null,
                    toughness: type === 'Creature' ? toughness : null,
                    loyalty: type === 'Planeswalker' ? document.getElementById('loyalty').value : null,
                };

                if (imageFile) {
                    const imageRef = storage.ref(`card-images/${Date.now()}-${imageFile.name}`);
                    const uploadTask = await imageRef.put(imageFile);
                    imageUrl = await uploadTask.ref.getDownloadURL();
                    cardDataToSave.imageUrl = imageUrl;
                }

                if (editingCardId) {
                    const cardRef = db.collection('cards').doc(editingCardId);
                    await cardRef.update(cardDataToSave);
                    
                    const cardIndex = allCards.findIndex(c => c.id === editingCardId);
                    if(cardIndex > -1) {
                        if (!cardDataToSave.imageUrl) {
                            cardDataToSave.imageUrl = allCards[cardIndex].imageUrl;
                        }
                        allCards[cardIndex] = { ...allCards[cardIndex], ...cardDataToSave };
                    }
                    showMessage(`Success: "${name}" was updated.`, false);
                } else {
                    cardDataToSave.imageUrl = imageUrl || null;
                    const docRef = await db.collection('cards').add(cardDataToSave);
                    allCards.push({ id: docRef.id, ...cardDataToSave });
                    showMessage(`Success: "${name}" was added.`, false);
                }
                
                renderCollection();
                resetForm();

            } catch (error) {
                console.error("Error saving card: ", error);
                showMessage("Failed to save card. Check console for details.");
            } finally {
                saveCardBtn.disabled = false;
            }
        };

        const deleteCard = async (cardId) => {
            const cardToDelete = allCards.find(c => c.id === cardId);
            if (!cardToDelete) return;

            const decks = getSavedDecks();
            const decksContainingCard = Object.entries(decks).filter(([name, deckData]) => {
                const cardIds = deckData.cardIds || deckData;
                return cardIds.includes(cardId);
            }).map(([name]) => name);

            let confirmMessage = `Are you sure you want to permanently delete "${cardToDelete.name}"?`;
            if (decksContainingCard.length > 0) {
                confirmMessage += `\n\nWarning: This card is in the following saved decks: ${decksContainingCard.join(', ')}. Deleting it will remove it from these decks.`;
            }

            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                await db.collection('cards').doc(cardId).delete();

                // FIXED: Only try to delete the image if it's a Firebase Storage URL
                if (cardToDelete.imageUrl && cardToDelete.imageUrl.includes('firebasestorage.googleapis.com')) {
                    const imageRef = storage.refFromURL(cardToDelete.imageUrl);
                    await imageRef.delete();
                }

                allCards = allCards.filter(c => c.id !== cardId);
                renderCollection();
                
                currentDeck = currentDeck.filter(c => c.id !== cardId);
                commanders = commanders.filter(c => c.id !== cardId);
                renderDeckList();

                Object.entries(decks).forEach(([name, deckData]) => {
                    const cardIds = deckData.cardIds || deckData;
                    const commanderIds = deckData.commanderIds || [];
                    const newCardIds = cardIds.filter(id => id !== cardId);
                    const newCommanderIds = commanderIds.filter(id => id !== cardId);
                    decks[name] = { cardIds: newCardIds, commanderIds: newCommanderIds };
                });
                saveDecks(decks);
                renderSavedDecks();

                showMessage(`Successfully deleted "${cardToDelete.name}".`, false);

            } catch (error) {
                console.error("Error deleting card:", error);
                showMessage("Failed to delete card. Check console for details.", true);
            }
        };

        const populateFormForEdit = (cardId) => {
            const card = allCards.find(c => c.id === cardId);
            if (!card) return;

            editingCardId = cardId;
            document.getElementById('cardName').value = card.name || '';
            document.getElementById('cardType').value = card.type || 'Creature';
            document.getElementById('cardSubtype').value = card.subtype || '';
            document.getElementById('manaCost').value = card.cost || '';
            document.getElementById('cardText').value = card.text || '';
            document.getElementById('cardFlavourText').value = card.flavourText || '';
            document.getElementById('power').value = card.power || '';
            document.getElementById('toughness').value = card.toughness || '';
            document.getElementById('loyalty').value = card.loyalty || '';

            cardTypeSelect.dispatchEvent(new Event('change'));
            
            formTitleEl.textContent = `Editing: ${card.name}`;
            saveCardBtn.textContent = 'Update Card';
            cancelEditBtn.classList.remove('hidden');
            window.scrollTo({ top: 0, behavior: 'smooth' });
        };

        const resetForm = () => {
            document.getElementById('addCardForm').reset();
            editingCardId = null;
            formTitleEl.textContent = 'Create New Card';
            saveCardBtn.textContent = 'Add to Collection';
            cancelEditBtn.classList.add('hidden');
            cardTypeSelect.dispatchEvent(new Event('change'));
        };
        
        const handleCreateGame = () => {
            hideMessage();
            const playerName = document.getElementById('playerName').value.trim();
            const startingLife = parseInt(document.getElementById('gameMode').value, 10);

            if (currentDeck.length === 0) {
                showMessage("Please assemble or load a deck before starting.", true);
                return;
            }
            if (!playerName) {
                showMessage("Please enter your name before starting.", true);
                return;
            }

            const gamesRef = realdb.ref('games');
            const newGameRef = gamesRef.push(); 

            const mainDeckForGame = currentDeck.filter(card => !commanders.some(c => c.id === card.id));

            const initialGameState = {
                players: {
                    p1: {
                        uid: myUserId,
                        name: playerName,
                        deck: mainDeckForGame,
                        commander: commanders,
                        hand: [], 
                        battlefield: [], 
                        graveyard: [], 
                        exile: [],
                        life: startingLife,
                        shuffled: false
                    }
                },
                createdAt: firebase.database.ServerValue.TIMESTAMP
            };

            newGameRef.set(initialGameState).then(() => {
                const gameId = newGameRef.key;
                const inviteLink = `${window.location.origin}/game.html?gameId=${gameId}`;
                
                inviteLinkInputEl.value = inviteLink;
                enterGameBtn.onclick = () => {
                    window.location.href = `game.html?gameId=${gameId}`;
                };

                lobbyControlsEl.classList.add('hidden');
                gameCreatedSectionEl.classList.remove('hidden');
                
            }).catch(error => {
                console.error("Could not create game session: ", error);
                showMessage("Error starting game. Could not connect to the server.");
            });
        };
        
        const handleCopyLink = () => {
            inviteLinkInputEl.select();
            document.execCommand('copy');
            copyLinkBtn.textContent = 'Copied!';
            setTimeout(() => {
                copyLinkBtn.textContent = 'Copy';
            }, 2000);
        };

        const handleJoinGame = () => {
            hideMessage();
            const gameId = joinGameIdInput.value.trim();
            const playerName = document.getElementById('playerName').value.trim();

            if (currentDeck.length === 0) {
                showMessage("Please assemble or load a deck before joining.", true);
                return;
            }
            if (!playerName) {
                showMessage("Please enter your name before joining.", true);
                return;
            }
            if (!gameId) {
                showMessage("Please enter a Game ID to join.", true);
                return;
            }

            const mainDeckForGame = currentDeck.filter(card => !commanders.some(c => c.id === card.id));

            const pendingJoinData = {
                playerName: playerName,
                deck: mainDeckForGame,
                commanders: commanders
            };
            localStorage.setItem('pendingJoinData', JSON.stringify(pendingJoinData));

            window.location.href = `game.html?gameId=${gameId}`;
        };

        // --- Deck Management ---
        const getSavedDecks = () => JSON.parse(localStorage.getItem('savedDecks')) || {};
        const saveDecks = (decks) => localStorage.setItem('savedDecks', JSON.stringify(decks));
        
        const addCardToDeck = (card) => {
            currentDeck.push(card);
            renderDeckList();
        };
        
        const removeCardFromDeck = (cardId) => {
            const index = currentDeck.findIndex(card => card.id == cardId);
            if (index > -1) {
                currentDeck.splice(index, 1);
                unsetCommander(cardId);
                renderDeckList();
            }
        };

        const setCommander = (card) => {
            if (!commanders.some(c => c.id === card.id)) {
                commanders.push(card);
                renderDeckList();
            }
        };

        const unsetCommander = (cardId) => {
            commanders = commanders.filter(c => c.id !== cardId);
            renderDeckList();
        };

        const handleSaveDeck = () => {
            hideMessage();
            const name = deckNameEl.value.trim();
            if (!name || currentDeck.length === 0) {
                showMessage('Please provide a deck name and add at least one card.', true);
                return;
            }
            const decks = getSavedDecks();
            decks[name] = {
                cardIds: currentDeck.map(c => c.id),
                commanderIds: commanders.map(c => c.id)
            };
            saveDecks(decks);
            renderSavedDecks();
            showMessage(`Success: Deck "${name}" has been saved!`, false);
        };

        const loadDeck = (name) => {
            const decks = getSavedDecks();
            if (decks[name]) {
                const deckData = decks[name];
                const cardIds = deckData.cardIds || [];
                const commanderIds = deckData.commanderIds || [];

                currentDeck = cardIds.map(id => allCards.find(card => card.id === id)).filter(Boolean);
                commanders = commanderIds.map(id => allCards.find(card => card.id === id)).filter(Boolean);

                deckNameEl.value = name;
                renderDeckList();
                showMessage(`Deck "${name}" loaded.`, false);
            }
        };

        const deleteDeck = (name) => {
            const decks = getSavedDecks();
            delete decks[name];
            saveDecks(decks);
            renderSavedDecks();
        };

        // --- BULK IMPORT (CSV) LOGIC ---
        const handleImageUpload = async (event) => {
            const zipFile = event.target.files[0];
            if (!zipFile) return;

            imageUploadProgressEl.textContent = `Unzipping and uploading images...`;
            uploadedImageMap.clear();

            try {
                const jszip = new JSZip();
                const zip = await jszip.loadAsync(zipFile);
                const imageFiles = [];
                zip.forEach((relativePath, zipEntry) => {
                    if (!zipEntry.dir && (zipEntry.name.endsWith('.png') || zipEntry.name.endsWith('.jpg') || zipEntry.name.endsWith('.jpeg'))) {
                        imageFiles.push(zipEntry);
                    }
                });

                imageUploadProgressEl.textContent = `Found ${imageFiles.length} images. Uploading...`;

                const uploadPromises = imageFiles.map(file => {
                    return file.async('blob').then(blob => {
                        const imageRef = storage.ref(`card-images/${Date.now()}-${file.name}`);
                        return imageRef.put(blob).then(uploadTask => {
                            return uploadTask.ref.getDownloadURL().then(imageUrl => {
                                uploadedImageMap.set(file.name, imageUrl);
                            });
                        });
                    });
                });

                await Promise.all(uploadPromises);
                imageUploadProgressEl.textContent = `Successfully uploaded ${imageFiles.length} images. Ready for CSV import.`;
                imageUploadProgressEl.style.color = '#4ade80';
            } catch (error) {
                console.error("Error processing zip file:", error);
                imageUploadProgressEl.textContent = "An error occurred during zip processing.";
                imageUploadProgressEl.style.color = '#f87171';
            }
        };

        const handleCsvImport = () => {
            const file = csvFileToProcess;
            if (!file) {
                showMessage("Please select a CSV file to import.", true, 'import');
                return;
            }
            showMessage("Parsing CSV file...", false, 'import');
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                complete: async (results) => {
                    if (results.errors && results.errors.length > 0) {
                        const errorMessages = results.errors.map(e => `Row ${e.row}: ${e.message}`).join('\n');
                        showMessage(`CSV parsing failed. Please check the file format. Errors:\n${errorMessages}`, true, 'import');
                        return;
                    }

                    const cardsToCreate = [];
                    const errors = [];
                    let skippedCount = 0;
                    const existingCardNames = new Set(allCards.map(c => c.name.toLowerCase()));
                    const namesInThisImport = new Set();

                    for (const row of results.data) {
                        const cardName = row['Card Name']?.trim();
                        const cardType = row['Card Type']?.trim();
                        if (!cardName || !cardType) {
                            errors.push(`Skipping row with missing Card Name or Card Type.`);
                            continue;
                        }
                        if (cardType === 'Creature' && (!row['Power'] || !row['Toughness'])) {
                            errors.push(`Skipping Creature "${cardName}" with missing Power or Toughness.`);
                            continue;
                        }

                        const lowerCaseCardName = cardName.toLowerCase();
                        if (!isBasicLand(cardName, cardType) && (existingCardNames.has(lowerCaseCardName) || namesInThisImport.has(lowerCaseCardName))) {
                            skippedCount++;
                            continue; 
                        }
                        namesInThisImport.add(lowerCaseCardName);

                        const cardData = {
                            name: cardName,
                            type: cardType,
                            subtype: row['Card Subtype']?.trim() || '',
                            cost: row['Mana Cost']?.trim() || '',
                            text: row['Text Box']?.trim() || '',
                            flavourText: row['Flavour Text']?.trim() || '',
                            imageUrl: row['Image Filename']?.trim() ? (uploadedImageMap.get(row['Image Filename'].trim()) || null) : null,
                            power: row['Power']?.trim() || null,
                            toughness: row['Toughness']?.trim() || null,
                            loyalty: row['Starting Loyalty']?.trim() || null
                        };
                        cardsToCreate.push(cardData);
                    }

                    if (errors.length > 0) showMessage(errors.join('\n'), true, 'import');
                    
                    if (cardsToCreate.length > 0) {
                        try {
                            const batch = db.batch();
                            cardsToCreate.forEach(cardData => {
                                const docRef = db.collection('cards').doc();
                                batch.set(docRef, cardData);
                            });
                            await batch.commit();
                            
                            let successMessage = `Successfully imported ${cardsToCreate.length} new cards!`;
                            if (skippedCount > 0) successMessage += ` Skipped ${skippedCount} duplicate cards.`;
                            showMessage(successMessage, false, 'import');
                            await loadAllCardsFromFirebase();
                        } catch (error) {
                            console.error("Error saving cards to Firestore:", error);
                            showMessage("An error occurred while saving new cards.", true, 'import');
                        }
                    } else {
                         let message = "No new cards were imported.";
                         if (skippedCount > 0) message += ` Skipped ${skippedCount} duplicate cards.`
                         showMessage(message, false, 'import');
                    }
                },
                error: (err) => showMessage(`Error parsing CSV file: ${err.message}.`, true, 'import')
            });
        };

        // --- SCRYFALL IMPORT LOGIC ---
        async function fetchCardsFromScryfall(names) {
            const allFoundCards = [];
            const allNotFoundNames = [];
            const CHUNK_SIZE = 75;

            for (let i = 0; i < names.length; i += CHUNK_SIZE) {
                const chunk = names.slice(i, i + CHUNK_SIZE);
                showMessage(`Fetching batch ${Math.floor(i / CHUNK_SIZE) + 1}... (${i + chunk.length}/${names.length})`, false, 'scryfall');
                const identifiers = chunk.map(name => ({ name }));

                try {
                    const response = await fetch('https://api.scryfall.com/cards/collection', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ identifiers }),
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`Scryfall API Error: ${errorData.details || response.statusText}`);
                    }
                    const result = await response.json();
                    if (result.data) allFoundCards.push(...result.data);
                    if (result.not_found) allNotFoundNames.push(...result.not_found.map(item => item.name));
                } catch (error) {
                    console.error("Error fetching chunk:", error);
                    allNotFoundNames.push(...chunk);
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            return { found: allFoundCards, notFound: allNotFoundNames };
        }

        function processScryfallCard(card) {
            const cardFace = card.card_faces ? card.card_faces[0] : card;
            const [type, subtype] = (card.type_line || '').split(' — ');
            return {
                name: card.name,
                type: type || '',
                source: 'scryfall',
                subtype: subtype || '',
                cost: cardFace.mana_cost || '',
                text: cardFace.oracle_text || '',
                power: card.power || null,
                toughness: card.toughness || null,
                loyalty: card.loyalty || null,
                flavourText: cardFace.flavor_text || '',
                imageUrl: card.image_uris?.normal || cardFace.image_uris?.normal || null,
            };
        }

        function displayResults(found, notFound) {
            foundCardsGrid.innerHTML = '';
            notFoundList.innerHTML = '';
            foundCount.textContent = found.length;
            found.forEach(cardData => {
                const cardWrapper = document.createElement('div');
                cardWrapper.className = 'text-center';
                const img = document.createElement('img');
                img.src = cardData.imageUrl || 'https://placehold.co/100x140/2d3748/e2e8f0?text=No+Image';
                img.alt = cardData.name;
                img.className = 'card-preview-img mx-auto';
                const name = document.createElement('p');
                name.textContent = cardData.name;
                name.className = 'text-xs mt-1';
                cardWrapper.appendChild(img);
                cardWrapper.appendChild(name);
                foundCardsGrid.appendChild(cardWrapper);
            });

            notFoundCount.textContent = notFound.length;
            if (notFound.length > 0) {
                document.getElementById('notFoundSection').classList.remove('hidden');
                notFound.forEach(name => {
                    const li = document.createElement('li');
                    li.textContent = name;
                    notFoundList.appendChild(li);
                });
            } else {
                 document.getElementById('notFoundSection').classList.add('hidden');
            }
            resultsArea.classList.remove('hidden');
        }

        function convertToCSV(data) {
            if (data.length === 0) return '';
            const headers = ['Card Name', 'Card Type', 'Card Subtype', 'Mana Cost', 'Text Box', 'Flavour Text', 'Power', 'Toughness', 'Starting Loyalty', 'Image Filename', 'Commander?'];
            const rows = data.map(card => {
                const isLegendary = /Legendary/.test(card.type_line);
                const isCreature = /Creature/.test(card.type_line);
                const isCommander = isLegendary && isCreature ? 'Y' : '';
                const values = [card.name, card.type, card.subtype, card.cost, card.text, card.flavourText, card.power, card.toughness, card.loyalty, '', isCommander];
                return values.map(val => {
                    const str = String(val === null || val === undefined ? '' : val);
                    if (str.includes(',') || str.includes('"') || str.includes('\n')) return `"${str.replace(/"/g, '""')}"`;
                    return str;
                }).join(',');
            });
            return [headers.join(','), ...rows].join('\n');
        }

        function downloadCSV(csvString) {
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-s8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'scryfall_import.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        async function handleFetchClick() {
            const inputText = cardListInput.value.trim();
            if (!inputText) {
                showMessage('Please enter at least one card name.', true, 'scryfall');
                return;
            }

            fetchBtn.disabled = true;
            fetchBtn.textContent = 'Fetching...';
            statusArea.innerHTML = '';
            resultsArea.classList.add('hidden');
            downloadCsvBtn.disabled = true;
            addDirectlyBtn.disabled = true;
            fetchedCardsData = [];

            const names = [...new Set(inputText.split('\n').map(name => name.trim()).filter(Boolean))];

            try {
                const { found, notFound } = await fetchCardsFromScryfall(names);
                fetchedCardsData = found.map(processScryfallCard);
                displayResults(fetchedCardsData, notFound);
                showMessage('Fetch complete!', false, 'scryfall');
                if (fetchedCardsData.length > 0) {
                    downloadCsvBtn.disabled = false;
                    addDirectlyBtn.disabled = false;
                }
            } catch (error) {
                console.error("An error occurred during the fetch process:", error);
                showMessage('An unexpected error occurred. Check the console for details.', true, 'scryfall');
            } finally {
                fetchBtn.disabled = false;
                fetchBtn.textContent = 'Fetch Card Data';
            }
        }

        async function handleAddDirectly() {
            addDirectlyBtn.disabled = true;
            addDirectlyBtn.textContent = 'Adding...';

            const cardsToCreate = [];
            let skippedCount = 0;
            const existingCardNames = new Set(allCards.map(c => c.name.toLowerCase()));

            for (const cardData of fetchedCardsData) {
                const lowerCaseCardName = cardData.name.toLowerCase();
                 if (!isBasicLand(cardData.name, cardData.type) && existingCardNames.has(lowerCaseCardName)) {
                    skippedCount++;
                    continue; 
                }
                cardsToCreate.push(cardData);
                existingCardNames.add(lowerCaseCardName); // Add to set to prevent duplicates within the same import
            }

            if (cardsToCreate.length > 0) {
                try {
                    const batch = db.batch();
                    cardsToCreate.forEach(cardData => {
                        const docRef = db.collection('cards').doc();
                        batch.set(docRef, cardData);
                    });
                    await batch.commit();
                    
                    let successMessage = `Successfully added ${cardsToCreate.length} new cards to your collection!`;
                    if (skippedCount > 0) successMessage += ` Skipped ${skippedCount} duplicate cards.`;
                    showMessage(successMessage, false, 'scryfall');

                    await loadAllCardsFromFirebase(); // Refresh the main collection view
                } catch (error) {
                    console.error("Error saving cards to Firestore:", error);
                    showMessage("An error occurred while saving new cards.", true, 'scryfall');
                }
            } else {
                let message = "No new cards were added.";
                if (skippedCount > 0) message += ` All ${skippedCount} fetched cards were already in your collection.`
                showMessage(message, false, 'scryfall');
            }

            addDirectlyBtn.textContent = 'Add to My Collection';
        }

        // --- INITIALIZATION ---
        async function init() {
            try {
                firebase.auth().onAuthStateChanged(async (user) => {
    if (user) {
        // User is signed in.
        myUserId = user.uid;
        console.log("DEBUG: User signed in with UID:", myUserId);

        // All the original setup code will now run *after* we confirm the user is logged in.
        // Main App Listeners
        saveCardBtn.addEventListener('click', handleSaveCard);
        cancelEditBtn.addEventListener('click', resetForm);
        saveDeckBtn.addEventListener('click', handleSaveDeck);
        createGameBtn.addEventListener('click', handleCreateGame);
        joinGameBtn.addEventListener('click', handleJoinGame);
        copyLinkBtn.addEventListener('click', handleCopyLink);

        // CSV Importer Listeners
        document.getElementById('bulkImageUpload').addEventListener('change', handleImageUpload);
        document.getElementById('csvFile').addEventListener('change', (event) => {
            if (event.target.files && event.target.files.length > 0) {
                csvFileToProcess = event.target.files[0];
            }
        });
        importCsvBtn.addEventListener('click', handleCsvImport);

        // Scryfall Importer Listeners
        fetchBtn.addEventListener('click', handleFetchClick);
        downloadCsvBtn.addEventListener('click', () => {
            const csv = convertToCSV(fetchedCardsData);
            downloadCSV(csv);
        });
        addDirectlyBtn.addEventListener('click', handleAddDirectly);

        // Collection Filter Listeners
        filterNameInput.addEventListener('input', renderFilteredCollection);
        filterTypeSelect.addEventListener('change', renderFilteredCollection);
        filterSortSelect.addEventListener('change', renderFilteredCollection);
        filterColorSelect.addEventListener('change', renderFilteredCollection);
        filterSourceSelect.addEventListener('change', renderFilteredCollection);

        // Initial Load
        await loadAllCardsFromFirebase();
        renderSavedDecks();
        cardTypeSelect.dispatchEvent(new Event('change'));

    } else {
        // No user is signed in. Redirect to the login page.
        window.location.href = 'index.html';
    }
});
                console.log("DEBUG: User signed in anonymously with UID:", myUserId);


            } catch (error) {
                console.error("Authentication or Initialization failed:", error);
                document.body.innerHTML = `<div class="text-red-400 p-8">Could not connect to the server. Please check the console and refresh the page. Error: ${error.message}</div>`;
            }
        }

        init();
    </script>
    <!-- NEW: Pop-out element for detailed card previews -->
    <div id="card-popout" class="rounded-lg shadow-2xl p-2 space-y-2">
        <div class="flex justify-between items-start">
            <span id="popout-name" class="font-bold"></span>
            <span id="popout-cost" class="text-sm flex gap-1 items-center"></span>
        </div>
        <img id="popout-img" src="" alt="Card Image" class="rounded-md">
        <div class="flex justify-between items-center text-sm">
            <span id="popout-type" class="font-semibold"></span>
            <span id="popout-pt" class="font-bold"></span>
        </div>
        <div id="popout-text" class="text-xs bg-gray-800 p-2 rounded-md whitespace-pre-wrap max-h-40 overflow-y-auto"></div>
        <div id="popout-flavour" class="text-xs text-gray-400 italic"></div>
    </div>
</body>
</html>
