<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Card Arena - Game Board</title>
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <!-- Our Firebase Initialization -->
    <script src="firebase-init.js"></script>
    <!-- SortableJS for Drag and Drop -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Custom Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
    html, body {
        height: 100%;
    }
    body {
        font-family: 'Inter', sans-serif;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        background-color: #111827; /* bg-gray-900 */
    }
    .game-zone {
        border: 2px dashed rgba(255, 255, 255, 0.2);
        border-radius: 0.5rem;
        padding: 0.5rem;
        background-color: rgba(255, 255, 255, 0.05);
        transition: background-color 0.2s;
        position: relative;
        display: flex; 
        flex-direction: column;
    }
    .clickable-zone {
        cursor: pointer;
    }
    .game-zone:hover {
        background-color: rgba(255, 255, 255, 0.1);
    }
    .zone-title {
        text-align: center;
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.4);
        position: absolute;
        top: 4px;
        left: 50%;
        transform: translateX(-50%);
        width: 100%;
        z-index: 10;
        pointer-events: none;
    }
    .player-hand {
        border-top: 2px solid rgba(99, 102, 241, 0.5);
        background-color: rgba(17, 24, 39, 0.9);
        backdrop-filter: blur(5px);
    }
    .my-player-area {
        outline: 2px solid #4f46e5;
        box-shadow: 0 0 20px rgba(79, 70, 229, 0.5);
    }
    .active-player-turn {
        outline: 2px solid #34d399; /* Green outline */
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.7);
    }
    .card { 
        height: 140px; 
        width: 100px;
        border-radius: 0.5rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        cursor: grab;
        background-size: cover;
        background-position: center;
        flex-shrink: 0;
        transition: transform 0.2s ease-in-out;
        position: relative; 
        background-color: #4b5563; /* For tokens */
        color: white; /* Ensures text on tokens is white */
    }
    .card:hover {
        transform: scale(1.1);
        z-index: 100;
    }
    .card.tapped {
       transform: rotate(90deg);
    }
    .sortable-ghost {
        opacity: 0.4;
        background-color: #4f46e5;
    }
    .sortable-drag {
        opacity: 0.9;
        transform: scale(1.05);
    }
    .life-total-input {
        background: transparent;
        border: none;
        color: white;
        text-align: center;
        width: 120px;
    }
    .life-total-input:focus {
        outline: 1px solid #4f46e5;
        border-radius: 4px;
    }
    input[type=number]::-webkit-inner-spin-button, 
    input[type=number]::-webkit-outer-spin-button { 
      -webkit-appearance: none; 
      margin: 0; 
    }
    input[type=number] {
      -moz-appearance: textfield;
    }
    .card-container {
        flex-grow: 1;
        padding-top: 1.5rem; 
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-content: flex-start;
    }

    .battlefield-grid {
    display: grid;
    /* This now defines 2 rows and lets the columns auto-fill */
    grid-template-rows: repeat(2, 1fr);
    grid-auto-flow: column;
    grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); 
    gap: 0.5rem;
    flex-grow: 1;
    padding-top: 1.5rem;
    }
    .grid-slot {
    border: 2px dashed rgba(255, 255, 255, 0.1);
    border-radius: 0.5rem;
    height: 170px; /* This sets a FIXED height to prevent vertical stretching */
    position: relative;
    }
    /* This new rule adds the slot number label */
    .grid-slot::before {
        content: attr(data-slot-id);
        position: absolute;
        top: 4px;
        left: 6px;
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.2);
    }
    .grid-slot .card {
    position: absolute;
    top: 0;
    left: 0;
    transition: top 0.2s ease-in-out; /* Add transition for smooth stacking */
    }

    /* Enables card stacking on the battlefield */
    .grid-slot .card.stacked {
        top: 25px; /* Nudge the second card down to create the overlap */
    }

    .context-menu {
        position: fixed;
        z-index: 10000;
        background-color: #1f2937; 
        border: 1px solid #4f46e5;
        border-radius: 0.5rem;
        padding: 0.5rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        width: 220px;
    }
    .context-menu-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.25rem 0.5rem;
        color: white;
        border-radius: 0.25rem;
    }
     .context-menu-button {
        display: block;
        width: 100%;
        padding: 0.5rem;
        text-align: left;
        border-radius: 0.25rem;
        color: white;
    }
    .context-menu-button:hover {
       background-color: #4f46e5;
    }
    .context-menu-divider {
        height: 1px;
        background-color: #374151;
        margin: 0.5rem 0;
    }
    .context-menu-input {
        background-color: #374151;
        border: 1px solid #4b5563;
        color: white;
        border-radius: 0.25rem;
        padding: 0.25rem 0.5rem;
        width: 100%;
    }

    .context-submenu {
        padding-left: 1rem; /* Indent the submenu items */
        border-left: 2px solid #4f46e5; /* Add a visual indicator */
        margin-left: 0.5rem;
        margin-top: 0.25rem;
    }
    .counter-badge-container {
        position: absolute;
        top: 2px;
        right: 2px;
        display: flex;
        flex-direction: column;
        gap: 2px;
        align-items: flex-end;
    }
    .counter-badge {
        background-color: rgba(17, 24, 39, 0.8);
        color: white;
        border-radius: 0.25rem;
        padding: 1px 5px;
        font-size: 0.7rem;
        font-weight: bold;
        border: 1px solid rgba(255,255,255,0.4);
        white-space: nowrap;
    }
    .deck-select-button {
        display: block;
        width: 100%;
        background-color: #374151;
        border: 1px solid #4b5563;
        padding: 0.75rem;
        border-radius: 0.5rem;
        text-align: left;
        font-weight: 500;
        transition: background-color 0.2s;
    }
    .deck-select-button:hover {
        background-color: #4f46e5;
    }
    .token {
        padding: 8px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        text-align: center;
        font-size: 12px;
        border: 2px solid #6b7280;
    }
    .token-name {
        font-weight: bold;
    }
    .token-pt {
        align-self: flex-end;
        background-color: rgba(17, 24, 39, 0.8);
        padding: 2px 6px;
        border-radius: 4px;
    }

    .token .token-name, .token .text-xs {
        background-color: rgba(17, 24, 39, 0.8); /* Dark, semi-transparent background */
        padding: 2px 4px;
        border-radius: 3px;
        width: fit-content; /* Make the background only as wide as the text */
        margin: 2px auto; /* Center the text blocks */
    }

    #card-popout {
        width: 280px;
        background-color: #1f2937;
        border: 1px solid #4f46e5;
        z-index: 9000;
        color: white;
    }
    #popout-img {
        width: 100%;
        height: 200px;
        object-fit: cover;
        background-color: #374151;
    }
    #popout-cost {
        display: flex;
        gap: 2px;
        align-items: center;
    }
    #popout-cost img {
        width: 16px;
        height: 16px;
    }
    #popout-text {
        color: white;
    }
    #zone-viewer-modal h2 {
        color: white;
    }
    .interactive-card-wrapper {
        display: flex;
        flex-direction: column;
        gap: 4px;
    }
    .action-button {
        padding: 4px 8px;
        font-size: 12px;
        border-radius: 4px;
        color: white;
        cursor: pointer;
    }
    #popout-flavour-text {
        font-style: italic;
        border-top: 1px solid #4b5563;
        padding-top: 8px;
        margin-top: 8px;
    }

    /* CHAT STYLES */
    #chat-toggle-button {
        position: fixed;
        bottom: 1rem;
        right: 1rem;
        z-index: 1001;
    }
    #chat-notification {
        position: absolute;
        top: 0px;
        right: 0px;
        width: 12px;
        height: 12px;
        border-radius: 9999px;
        background-color: #ef4444; /* red-500 */
        border: 2px solid #4338ca; /* indigo-700 */
    }
    #chat-container {
        position: fixed;
        bottom: 1rem;
        right: 1rem;
        width: 320px;
        height: 450px;
        background-color: rgba(31, 41, 55, 0.95); /* bg-gray-800 */
        backdrop-filter: blur(8px);
        border: 1px solid #4f46e5; /* indigo-500 */
        border-radius: 0.75rem;
        display: flex;
        flex-direction: column;
        z-index: 1000;
        box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
    }
    #chat-messages {
        font-size: 0.875rem;
        line-height: 1.5;
    }
    #chat-messages > div {
        padding: 2px 0;
        word-wrap: break-word;
        color: white;
    }
    #chat-messages strong {
        color: #a5b4fc; /* indigo-300 */
        font-weight: 600;
    }
    #chat-input {
        color: white;
    }

    /* STATE-BASED VISIBILITY LOGIC */
    body[data-chat-state="open"] #chat-toggle-button {
        display: none;
    }
    body[data-chat-state="open"] #chat-container {
        display: flex;
    }
    body[data-chat-state="closed"] #chat-toggle-button {
        display: inline-flex;
    }
    body[data-chat-state="closed"] #chat-container {
        display: none;
    }
    @keyframes roll-animation {
        0% { transform: scale(1); }
        25% { transform: scale(1.2) rotate(15deg); }
        50% { transform: scale(1); }
        75% { transform: scale(1.2) rotate(-15deg); }
        100% { transform: scale(1); }
    }
    .dice-rolling {
        animation: roll-animation 0.5s ease-in-out;
    }

    .game-zone[data-click-type="left"] {
        border-color: rgba(59, 130, 246, 0.5); /* Blue for "View" */
    }
    .game-zone[data-click-type="right"] {
        border-color: rgba(234, 179, 8, 0.5); /* Yellow for "Menu" */
    }
    .game-zone[data-click-type="both"] {
        border-color: rgba(16, 185, 129, 0.5); /* Green for "Both" */
    }
    .title-container {
            display: flex;
            align-items: center;
            gap: 0.75rem; /* 12px */
        }
        .info-icon {
            display: inline-block;
            position: relative;
            cursor: pointer;
            width: 20px;
            height: 20px;
            border-radius: 9999px;
            background-color: #4b5563; /* bg-gray-600 */
            color: white;
            text-align: center;
            font-weight: bold;
            line-height: 20px;
            font-size: 14px;
        }
        .tooltip-text {
            visibility: hidden;
            width: 220px;
            background-color: #1f2937; /* bg-gray-800 */
            color: #fff;
            text-align: center;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #4f46e5; /* border-indigo-500 */
            position: absolute;
            z-index: 100; /* Increased z-index to ensure it's on top of other modal content */
            top: 125%; /* Changed from 'bottom' to 'top' to appear below */
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Fine-tune centering */
            opacity: 0;
            transition: opacity 0.3s;
        }
        .info-icon:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

</style>
</head>
<body data-chat-state="closed" class="text-white">

    <header class="flex-shrink-0 bg-gray-800 p-2 flex justify-between items-center shadow-md">
        <div class="text-xs">Game ID: <span id="gameIdDisplay" class="font-mono bg-gray-700 px-2 py-1 rounded"></span></div>

        <div class="hidden md:flex items-center text-xs space-x-4 text-gray-400">
            <span><b class="text-blue-400">■ Blue:</b> Left-Click to View</span>
            <span><b class="text-yellow-400">■ Yellow:</b> Right-Click for Menu</span>
            <span><b class="text-green-400">■ Green:</b> Both</span>
        </div>
                <div class="flex items-center gap-4">
            <button id="changeBackgroundBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-3 rounded-lg text-xs">Change Background</button>
            <button id="leaveGameBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-lg text-xs">Leave Game</button>
        </div>
    </header>

    <main class="main-grid flex-grow p-2">
        <!-- The game board grid will be dynamically inserted here by setupBoardHTML() -->
    </main>
    
    <div id="main-player-hand-area" class="player-hand flex-shrink-0 h-48 p-2 flex gap-4 relative hidden">
        <!-- NEW: Game Actions Panel -->
        <div id="game-actions-panel" class="w-40 flex-shrink-0 bg-gray-900/50 rounded-lg p-2 flex flex-col gap-2 justify-start">
            <h3 class="text-lg font-semibold text-center text-indigo-400 mb-2">Game Actions</h3>
            <button id="untapAllBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-2 rounded-lg text-sm">Untap All Cards</button>
            <button id="passTurnBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-2 rounded-lg text-sm disabled:bg-gray-600 disabled:cursor-not-allowed">Pass Turn</button>
            <button id="create-token-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-2 rounded-lg text-sm">Create Token</button>
            <!-- Spacer to push future buttons up -->
            <div class="flex-grow"></div>
        </div>

        <!-- Hand Area -->
        <div class="flex-grow flex flex-col relative">
            <div class="zone-title">HAND</div>
            <div id="main-player-hand-cards" data-zone-name="hand" class="card-container w-full h-full justify-center items-center"></div>
        </div>
    </div>
    
    <div id="zone-viewer-modal" class="hidden fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg max-w-6xl w-full max-h-full overflow-y-auto p-6 relative shadow-2xl border border-indigo-500">
            <div class="flex justify-between items-center mb-4">
                                <div class="title-container">
                    <h2 id="zone-viewer-title" class="text-2xl font-bold text-indigo-300">Zone</h2>
                    <div id="commander-info-icon" class="info-icon" style="display: none;">i
                        <span class="tooltip-text">Right-click a commander card to change its cast count.</span>
                    </div>
                </div>
                                <button id="finish-interactive-btn" class="hidden bg-green-600 text-white font-bold py-2 px-4 rounded-lg">Finish</button>
            </div>
            <button id="zone-viewer-close" class="absolute top-4 right-4 text-3xl font-light text-gray-400 hover:text-white leading-none">&times;</button>
            <div id="zone-viewer-content" data-zone-name="" class="card-container min-h-[150px] justify-center">
                <!-- Cards for the zone being viewed will be inserted here -->
            </div>
        </div>
    </div>
    
    <div id="library-search-modal" class="hidden fixed inset-0 bg-black/80 z-50 flex flex-col p-4">
        <div class="bg-gray-800 rounded-lg max-w-7xl w-full max-h-full mx-auto flex flex-col p-6 shadow-2xl border border-indigo-500">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 class="text-2xl font-bold text-indigo-300">Search Library</h2>
                <button id="library-search-close" class="text-3xl font-light text-gray-400 hover:text-white leading-none">&times;</button>
            </div>
            <input type="text" id="library-search-input" placeholder="Search by card name..." class="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white mb-4 flex-shrink-0">
            <div id="library-search-content" data-zone-name="deck" class="card-container flex-grow overflow-y-auto justify-center"></div>
        </div>
    </div>

    <div id="context-menu" class="context-menu hidden"></div>
    
    <div id="deck-selection-modal" class="hidden fixed inset-0 bg-black/90 z-50 flex items-center justify-center p-4">
         <div class="bg-gray-800 rounded-lg max-w-md w-full p-6 shadow-2xl border border-indigo-500">
            <h2 class="text-2xl font-bold mb-4 text-indigo-300">Select Your Deck</h2>
            <div class="mb-4">
                <label for="joiningPlayerName" class="block text-sm font-medium text-gray-400">Your Name</label>
                <input type="text" id="joiningPlayerName" placeholder="Enter your name..." class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <p class="text-gray-400 mb-6">Choose one of your saved decks to join the game.</p>
            <div id="deck-selection-list" class="space-y-2">
                <!-- Deck buttons will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <div id="token-creator-modal" class="hidden fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg max-w-md w-full p-6 shadow-2xl border border-indigo-500">
            <h2 class="text-2xl font-bold mb-4 text-indigo-300">Create Token</h2>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-400">Common Tokens</label>
                    <select id="common-token-select" class="w-full mt-1 context-menu-input">
                        <option value="">-- Select a common token --</option>
                        <option value="Treasure">Treasure (Artifact)</option>
                        <option value="Food">Food (Artifact)</option>
                        <option value="Clue">Clue (Artifact)</option>
                        <option value="1/1 Human">1/1 Human (White)</option>
                        <option value="1/1 Goblin">1/1 Goblin (Red)</option>
                        <option value="1/1 Elf Warrior">1/1 Elf Warrior (Green)</option>
                        <option value="2/2 Zombie">2/2 Zombie (Black)</option>
                    </select>
                </div>
                <div class="context-menu-divider">OR</div>
                 <div>
                    <label class="block text-sm font-medium text-gray-400">Custom Token</label>
                    <input type="text" id="token-name" placeholder="Token Name" class="w-full mt-1 context-menu-input">
                </div>
                 <div>
                    <input type="text" id="token-pt" placeholder="P/T (e.g., 2/2)" class="w-full mt-1 context-menu-input">
                </div>
                 <div>
                    <textarea id="token-text" placeholder="Abilities..." rows="2" class="w-full mt-1 context-menu-input"></textarea>
                </div>
                <div class="flex gap-4">
                     <button id="token-creator-cancel" class="w-full bg-gray-600 text-white py-2 rounded">Cancel</button>
                     <button id="token-creator-create" class="w-full bg-indigo-600 text-white py-2 rounded">Create</button>
                </div>
            </div>
        </div>
    </div>

    <div id="opening-hand-modal" class="hidden fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg max-w-md w-full p-6 shadow-2xl border border-indigo-500">
            <h2 class="text-2xl font-bold mb-4 text-indigo-300">Opening Hand</h2>
            <p id="opening-hand-message" class="text-gray-300 mb-6">Your opening hand contains X lands.</p>
            <div class="flex flex-col gap-3">
                <button id="keep-hand-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Keep Hand</button>
                <button id="mulligan-btn" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg">Mulligan (Shuffle)</button>
                <button id="opening-hand-cancel-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Cancel</button>
            </div>
        </div>
    </div>

    <div id="card-popout" class="hidden fixed rounded-lg shadow-2xl pointer-events-none p-2 space-y-2">
        <div class="flex justify-between items-start">
            <span id="popout-name" class="font-bold"></span>
            <span id="popout-cost" class="text-sm"></span>
        </div>
        <img id="popout-img" src="" alt="Card Image" class="rounded-md">
        <div class="flex justify-between items-center text-sm">
            <span id="popout-type" class="font-semibold"></span>
            <span id="popout-pt" class="font-bold"></span>
        </div>
        <div id="popout-text" class="text-xs bg-gray-800 p-2 rounded-md whitespace-pre-wrap"></div>
        <div id="popout-flavour-text" class="text-xs text-gray-400"></div>
    </div>

    <!-- CHAT HTML -->
    <button id="chat-toggle-button" class="bg-indigo-600 p-3 rounded-full shadow-lg relative transition-transform hover:scale-110">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" /></svg>
        <div id="chat-notification" class="hidden"></div>
    </button>
    
    <div id="chat-container">
        <div class="flex justify-between items-center p-2 bg-gray-900/50 rounded-t-lg">
            <h3 class="font-bold text-indigo-300">Game Chat</h3>
            <button id="chat-minimize-button" class="p-1 rounded-full hover:bg-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M5 10a1 1 0 011-1h8a1 1 0 110 2H6a1 1 0 01-1-1z" clip-rule="evenodd" />
                </svg>
            </button>
        </div>
        <div id="chat-messages" class="flex-grow p-2 overflow-y-auto"></div>
        <div class="p-2 border-t border-gray-700">
            <input type="text" id="chat-input" placeholder="Type a message..." class="w-full p-2 text-white bg-gray-700 rounded-md border border-gray-600 focus:outline-none focus:ring-1 focus:ring-indigo-500">
        </div>
    </div>

    <input type="file" id="background-uploader" class="hidden" accept="image/*">


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let gameState = {};
            let myPlayerId = null; 
            let myUserId = null;   
            let gameId = null;
            let gameRef = null;
            let sortableInstances = [];
            let modalSortable = null;
            let contextMenuCard = null;
            let longPressTimer;
            let allCardsFromDb = [];
            let cardDataMap = new Map();
            let resizeTimeout;
            let pendingOpeningHand = [];
            let interactiveActionState = {
                active: false,
                mode: null,
                count: 0,
                cards: [],
                toTop: [],
                toBottom: [],
                toGraveyard: []
            };

            const PLAYER_COLORS = [
                'rgba(34, 197, 94, 0.8)', // Player 1: Green 
                'rgba(59, 130, 246, 0.8)', // Player 2: Blue 
                'rgba(234, 179, 8, 0.8)', // Player 3: Yellow
                'rgba(239, 68, 68, 0.8)' // Player 4: Red  
            ];

            const COMMON_TOKEN_IMAGES = {
                'Treasure': 'https://firebasestorage.googleapis.com/v0/b/project-card-arena.firebasestorage.app/o/tokens%2FTreasure%20Token.png?alt=media&token=2627be0b-c378-4d7a-b8fa-41efb35f57b7',
                'Food': 'https://firebasestorage.googleapis.com/v0/b/project-card-arena.firebasestorage.app/o/tokens%2FFood%20Token.png?alt=media&token=87d31a1d-81ae-490f-b862-a9e48a95ebec',
                'Clue': 'https://firebasestorage.googleapis.com/v0/b/project-card-arena.firebasestorage.app/o/tokens%2FClue%20Token.png?alt=media&token=8fc18b7a-328a-4672-8105-a584a23a8b1a',
                '1/1 Human': 'https://firebasestorage.googleapis.com/v0/b/project-card-arena.firebasestorage.app/o/tokens%2FHuman%20Token.png?alt=media&token=6485390a-f9e5-4a4c-81c2-dfbe904fb2a6',
                '1/1 Goblin': 'https://firebasestorage.googleapis.com/v0/b/project-card-arena.firebasestorage.app/o/tokens%2FGoblin%20Token.png?alt=media&token=e89e0554-6a91-4fad-bd84-b0453fadffc8',
                '1/1 Elf Warrior': 'https://firebasestorage.googleapis.com/v0/b/project-card-arena.firebasestorage.app/o/tokens%2FElf%20Warrior%20Token.png?alt=media&token=9d1f1437-5323-4282-90ed-457bd3e65b7c',
                '2/2 Zombie': 'https://firebasestorage.googleapis.com/v0/b/project-card-arena.firebasestorage.app/o/tokens%2FZombie%20Token.png?alt=media&token=52dc087a-eb03-4692-809b-899de3e98d30'
            };
            const mainGridEl = document.querySelector('.main-grid');
            const handAreaEl = document.getElementById('main-player-hand-area');
            const handCardsEl = document.getElementById('main-player-hand-cards');
            const gameIdDisplayEl = document.getElementById('gameIdDisplay');
            const zoneViewerModal = document.getElementById('zone-viewer-modal');
            const zoneViewerTitle = document.getElementById('zone-viewer-title');
            const zoneViewerContent = document.getElementById('zone-viewer-content');
            const zoneViewerClose = document.getElementById('zone-viewer-close');
            const contextMenu = document.getElementById('context-menu');
            const deckSelectionModal = document.getElementById('deck-selection-modal');
            const deckSelectionList = document.getElementById('deck-selection-list');
            const tokenCreatorModal = document.getElementById('token-creator-modal');
            const cardPopoutEl = document.getElementById('card-popout');
            const popoutNameEl = document.getElementById('popout-name');
            const popoutCostEl = document.getElementById('popout-cost');
            const popoutImgEl = document.getElementById('popout-img');
            const popoutTypeEl = document.getElementById('popout-type');
            const popoutPtEl = document.getElementById('popout-pt');
            const popoutTextEl = document.getElementById('popout-text');
            const popoutFlavourTextEl = document.getElementById('popout-flavour-text');
            const librarySearchModal = document.getElementById('library-search-modal');
            const librarySearchClose = document.getElementById('library-search-close');
            const librarySearchInput = document.getElementById('library-search-input');
            const librarySearchContent = document.getElementById('library-search-content');
            const finishInteractiveBtn = document.getElementById('finish-interactive-btn');
            const leaveGameBtn = document.getElementById('leaveGameBtn');
            
            // CHAT ELEMENT REFERENCES
            const chatContainer = document.getElementById('chat-container');
            const chatToggleButton = document.getElementById('chat-toggle-button');
            const chatMinimizeButton = document.getElementById('chat-minimize-button');
            const chatNotification = document.getElementById('chat-notification');
            const chatMessagesEl = document.getElementById('chat-messages');
            const chatInputEl = document.getElementById('chat-input');

            const untapAllBtn = document.getElementById('untapAllBtn');

            const keepHandBtn = document.getElementById('keep-hand-btn');
            const mulliganBtn = document.getElementById('mulligan-btn');
            const openingHandCancelBtn = document.getElementById('opening-hand-cancel-btn');

            const encodeFirebaseKey = (str) => str.replace(/\//g, '__slash__');
            const decodeFirebaseKey = (str) => str.replace(/__slash__/g, '/');

            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            function getPlayerOrder(players) {
                const playerIds = Object.keys(players).sort(); 
                const myIndex = playerIds.indexOf(myPlayerId);
                if (myIndex === -1) return playerIds; 
                return [...playerIds.slice(myIndex), ...playerIds.slice(0, myIndex)];
            }
            
            function createCardElement(card) {
                const el = document.createElement('div');
                el.dataset.instanceId = card.instanceId;
                el.className = 'card';

                // Handle image backgrounds for cards and tokens with images
                if (card.imageUrl) {
                    el.style.backgroundImage = `url(${card.imageUrl})`;
                }

                // If it's a token, add the text overlay elements
                if (card.isToken) {
                    el.classList.add('token');
                    // If there's no image, the text will appear on the default gray background
                    el.innerHTML = `
                        <div class="token-name">${card.name}</div>
                        <div class="text-xs">${card.text || ''}</div>
                        <div class="token-pt">${card.pt || ''}</div>
                    `;
                }

                if (card.tapped) el.classList.add('tapped');
                
                const badgeContainer = document.createElement('div');
                badgeContainer.className = 'counter-badge-container';
                el.appendChild(badgeContainer);
                
                if (card.counters) {
                    Object.entries(card.counters).forEach(([name, count]) => {
                        if (count > 0) {
                            const decodedName = decodeFirebaseKey(name);
                            const badge = document.createElement('div');
                            badge.className = 'counter-badge';
                            badge.textContent = `${decodedName} (${count})`;
                            badgeContainer.appendChild(badge);
                        }
                    });
                }
                return el;
            }

            function updateOwnershipIndicator(cardEl) {
                // Safety check to make sure we're dealing with a valid card element
                if (!cardEl || !cardEl.dataset.instanceId) return;

                const instanceId = cardEl.dataset.instanceId;
                const cardData = cardDataMap.get(instanceId);

                // We only care about cards that have an owner
                if (!cardData || !cardData.ownerId) return;

                // Find the player area the card is currently in
                const playerArea = cardEl.closest('.player-area');
                
                // Remove any old owner tag from previous versions, just in case
                const existingTag = cardEl.querySelector('.owner-tag');
                if (existingTag) existingTag.remove();

                if (playerArea) {
                    const battlefieldOwnerId = playerArea.id.replace('player-area-', '');
                    
                    // If the card's owner is NOT the same as the battlefield controller...
                    if (cardData.ownerId !== battlefieldOwnerId) {
                        // Look up the original owner's color from the game state
                        const ownerColor = gameState.players[cardData.ownerId]?.color || 'rgba(255, 255, 255, 0.7)'; // Default to white glow
                        
                        // Apply a glow using the owner's specific color
                        cardEl.style.boxShadow = `0 0 12px 4px ${ownerColor}`; 
                    } else {
                        // If the owner and controller ARE the same, reset the card's style.
                        cardEl.style.boxShadow = ''; 
                    }
                } else {
                    // If the card is not in a player area (e.g., in the hand), reset its style.
                    cardEl.style.boxShadow = '';
                }
            }

            function updateCardContainer(containerEl, newCards = []) {
                const existingCardElements = new Map();
                containerEl.querySelectorAll('.card').forEach(el => {
                    existingCardElements.set(el.dataset.instanceId, el);
                });

                const newCardIds = new Set(newCards.map(c => c && c.instanceId));

                existingCardElements.forEach((el, instanceId) => {
                    if (!newCardIds.has(instanceId)) {
                        containerEl.removeChild(el);
                    }
                });

                newCards.forEach((cardData, index) => {
                    if (!cardData) return;
                    let cardEl = existingCardElements.get(cardData.instanceId);
                    if (!cardEl) {
                        cardEl = createCardElement(cardData);
                    } else {
                        cardEl.classList.toggle('tapped', !!cardData.tapped);
                        const badgeContainer = cardEl.querySelector('.counter-badge-container');
                        badgeContainer.innerHTML = ''; 
                        if (cardData.counters) {
                            Object.entries(cardData.counters).forEach(([name, count]) => {
                                if(count > 0) {
                                    const decodedName = decodeFirebaseKey(name);
                                    const badge = document.createElement('div');
                                    badge.className = 'counter-badge';
                                    badge.textContent = `${decodedName} (${count})`;
                                    badgeContainer.appendChild(badge);
                                }
                            });
                        }
                    }
                    
                    if (containerEl.children[index] !== cardEl) {
                        containerEl.insertBefore(cardEl, containerEl.children[index]);
                    }
                });
            }

            function renderBoard() {
                if (!gameState || !gameState.players || !myPlayerId) return;

                const myPlayerState = gameState.players[myPlayerId];
                if (myPlayerId !== 'p1' && myPlayerState && !myPlayerState.deckLoaded) {
                    showDeckSelectionModal(myPlayerId); // Pass the correct player ID
                    return;
                }
                
                deckSelectionModal.classList.add('hidden');

                const orderedPlayerIds = getPlayerOrder(gameState.players);
                const playerCount = orderedPlayerIds.length;
                const boardPlayerCount = mainGridEl.querySelectorAll('.player-area').length;
                
                if (playerCount !== boardPlayerCount) {
                    setupBoardHTML(orderedPlayerIds);
                }

                cardDataMap.clear();
                Object.values(gameState.players).forEach(player => {
                    if (!player) return;
                    const arrayZones = ['hand', 'graveyard', 'exile', 'commander', 'deck'];

                    // Handle array-based zones first
                    arrayZones.forEach(zoneKey => {
                        if (player[zoneKey] && Array.isArray(player[zoneKey])) {
                            player[zoneKey].forEach(card => {
                                if (card && card.instanceId) cardDataMap.set(card.instanceId, card);
                            });
                        }
                    });

                    // Handle the object-based battlefield zone separately, looking inside stacks
                    if (player.battlefield && typeof player.battlefield === 'object') {
                        Object.values(player.battlefield).flat().forEach(card => { // .flat() is key for handling stacks
                            if (card && card.instanceId) cardDataMap.set(card.instanceId, card);
                        });
                    }
                });

                const currentPlayerId = gameState.turnOrder[gameState.currentPlayerIndex];
                const currentPlayer = gameState.players[currentPlayerId];
                
                const turnIndicatorEl = document.getElementById('turn-indicator');
                const passTurnBtn = document.getElementById('passTurnBtn');

                if (currentPlayer && turnIndicatorEl) {
                    turnIndicatorEl.textContent = `${currentPlayer.name}'s Turn`;
                }
                if (passTurnBtn) {
                    passTurnBtn.disabled = currentPlayerId !== myPlayerId;
                }

                document.querySelectorAll('.player-area').forEach(el => el.classList.remove('active-player-turn'));
                if (currentPlayerId) {
                    document.getElementById(`player-area-${currentPlayerId}`)?.classList.add('active-player-turn');
                }


                orderedPlayerIds.forEach(playerId => {
                    const playerState = gameState.players[playerId];
                    if (!playerState) return;
                    
                    const playerArea = document.getElementById(`player-area-${playerId}`);
                    if(playerArea) {
                        const nameEl = playerArea.querySelector('.player-name-display');
                        if (nameEl) {
                           nameEl.textContent = playerState.name || (playerId === myPlayerId ? 'YOU' : 'OPPONENT');
                        }
                    }
                    
                    const battlefieldGridEl = document.getElementById(`${playerId}-battlefield-grid`);
                    if (battlefieldGridEl) {
                        // First, clear all cards from the grid slots
                        battlefieldGridEl.querySelectorAll('.grid-slot').forEach(slot => {
                            slot.innerHTML = ''; // This will remove ALL cards from the slot
                        });

                        // Now, place cards from the new data structure into the grid
                        const battlefieldCards = playerState.battlefield || {};
                        Object.entries(battlefieldCards).forEach(([slotId, cardArray]) => {
                            const slot = battlefieldGridEl.querySelector(`[data-slot-id="${slotId}"]`);
                            if (slot && Array.isArray(cardArray)) {
                                cardArray.forEach((cardData, index) => {
                                    if (cardData) {
                                        const cardEl = createCardElement(cardData);
                                        if (index > 0) { // If it's not the first card in the slot
                                            cardEl.classList.add('stacked');
                                        }
                                        slot.appendChild(cardEl);
                                    updateOwnershipIndicator(cardEl);
                                    }
                                });
                            }
                        });
                    }
                    
                    document.getElementById(`${playerId}-graveyard`).querySelector('.zone-title').textContent = `GRAVEYARD (${(playerState.graveyard || []).length})`;
                    document.getElementById(`${playerId}-exile`).querySelector('.zone-title').textContent = `EXILE (${(playerState.exile || []).length})`;
                    const commanderZone = playerState.commander || [];
                    let totalTax = 0;
                    // Calculate the total tax from all commanders in the zone
                    commanderZone.forEach(card => {
                        if (card && card.castCount > 0) {
                            totalTax += card.castCount * 2;
                        }
                    });

                    let commanderTitle = `COMMANDER (${commanderZone.length})`;
                    if (totalTax > 0) {
                        // Append the tax to the title if it's greater than zero
                        commanderTitle += ` | Tax: +${totalTax}`;
                    }
                    document.getElementById(`${playerId}-commander`).querySelector('.zone-title').textContent = commanderTitle;
                    document.getElementById(`${playerId}-library`).querySelector('.zone-title').textContent = `LIBRARY (${(playerState.deck || []).length})`;
                    document.getElementById(`${playerId}-life-total`).value = playerState.life ?? 40;

                    const handSizeEl = document.getElementById(`${playerId}-hand-size`);
                    if (handSizeEl) {
                        handSizeEl.textContent = `Hand: ${(playerState.hand || []).length}`;
                    }

                    document.querySelectorAll(`#${playerId}-graveyard .card, #${playerId}-exile .card, #${playerId}-library .card, #${playerId}-commander .card`).forEach(c => c.remove());
                });

                if (myPlayerState) {
                    handAreaEl.classList.remove('hidden');
                    updateCardContainer(handCardsEl, myPlayerState.hand || []);
                    handAreaEl.querySelector('.zone-title').textContent = `HAND (${(myPlayerState.hand || []).length})`;
                }
                
                initializeDragAndDrop();
                addCardEventListeners();
            }

            // Calculate Battlefield grid slots
            function calculateAndCreateSlots(gridEl) {
                if (!gridEl) return;

                const slotWidth = 110; // The minimum width of a card slot
                const gap = 8; // The space between slots (0.5rem)
                const gridWidth = gridEl.offsetWidth;

                // Calculate how many columns can fit in the available width
                const numCols = Math.floor(gridWidth / (slotWidth + gap));
                const totalSlots = numCols * 2; // We want two rows

                gridEl.innerHTML = ''; // Clear any old slots
                for (let i = 0; i < totalSlots; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'grid-slot';
                    slot.dataset.slotId = i + 1; // Start labeling from 1 instead of 0
                    gridEl.appendChild(slot);
                }
            }

            function setupBoardHTML(orderedPlayerIds) {
                 const playerCount = orderedPlayerIds.length;
                let gridWrapperClass = 'w-full h-full grid gap-2';
                if (playerCount <= 2) {
                    gridWrapperClass += ' grid-rows-2';
                } else {
                    gridWrapperClass += ' grid-cols-2 grid-rows-2';
                }
                const screenPositions = {
                    1: ['row-start-2 col-span-2'],
                    2: ['row-start-2', 'row-start-1'],
                    3: ['row-start-2 col-span-2', 'row-start-1 col-start-1', 'row-start-1 col-start-2'],
                    4: ['row-start-2 col-start-1', 'row-start-1 col-start-1', 'row-start-1 col-start-2', 'row-start-2 col-start-2']
                };
                const positionsToUse = screenPositions[playerCount] || [];
                
                let boardHTML = `<div class="${gridWrapperClass}">`;
                orderedPlayerIds.forEach((playerId, index) => {
                    const isMe = playerId === myPlayerId;
                    const playerState = gameState.players[playerId] || {};
                    boardHTML += `
                        <div id="player-area-${playerId}" class="player-area bg-gray-900/80 rounded-lg p-2 flex gap-2 overflow-hidden ${positionsToUse[index] || ''} ${isMe ? 'my-player-area' : ''}">
                            <div class="flex-shrink-0 w-24 md:w-32 lg:w-40 flex flex-col gap-2">
                                <div id="${playerId}-commander" data-click-type="left" class="game-zone h-1/4 clickable-zone"><div class="zone-title">COMMANDER (0)</div><div id="${playerId}-commander-cards" data-zone-name="commander" class="card-container"></div></div>
                                <div id="${playerId}-library" ${isMe ? 'data-click-type="both"' : ''} class="game-zone h-1/4 ${isMe ? 'clickable-zone' : ''}"><div class="zone-title">LIBRARY (0)</div><div data-zone-name="library" class="card-container"></div></div>
                                <div id="${playerId}-graveyard" data-click-type="left" class="game-zone h-1/4 clickable-zone"><div class="zone-title">GRAVEYARD (0)</div><div data-zone-name="graveyard" class="card-container"></div></div>
                                <div id="${playerId}-exile" data-click-type="left" class="game-zone h-1/4 clickable-zone"><div class="zone-title">EXILE (0)</div><div data-zone-name="exile" class="card-container"></div></div>
                            </div>
                            <div id="${playerId}-battlefield-wrapper" class="game-zone flex-grow">
                                <div class="zone-title">BATTLEFIELD</div>
                                <div id="${playerId}-battlefield-grid" data-zone-name="battlefield" class="battlefield-grid"></div>
                            </div>
                            <div class="flex-shrink-0 w-24 md:w-32 flex flex-col items-center justify-between bg-gray-800/80 rounded-lg p-2">
                                ${isMe ? `
                                    <div class="w-full text-center">
                                        <div id="turn-indicator" class="font-bold text-sm mb-1"></div>
                                    </div>

                                    <!-- NEW D20 DICE ROLLER ELEMENT -->
                                    <div id="dice-roller" class="my-2 flex flex-col items-center cursor-pointer group">
                                        <div id="d20-icon" class="w-12 h-12 border-2 border-gray-500 rounded-lg flex items-center justify-center text-2xl font-bold group-hover:bg-gray-700 transition-colors">
                                            <span id="d20-result">20</span>
                                        </div>
                                        <span class="text-xs text-gray-500 mt-1">Roll d20</span>
                                    </div>
                                    <!-- END OF NEW ELEMENT -->

                                    <div class="flex flex-col items-center">
                                        
                                        <div class="flex items-center justify-between w-full">
                                            <span class="player-name-display font-bold text-gray-400 text-xs md:text-sm">${playerState.name || 'YOU'}</span>
                                            <span id="${playerId}-hand-size" class="text-xs text-gray-400">Hand: 0</span>
                                        </div>

                                        <input type="number" id="${playerId}-life-total" class="life-total-input text-4xl lg:text-5xl font-bold" value="40">
                                        <div class="flex gap-1 md:gap-2 mt-2">
                                            <button data-player-id="${playerId}" data-action="decrement" class="bg-red-600 w-8 h-8 md:w-10 md:h-10 text-xl md:text-2xl rounded-full">-</button>
                                            <button data-player-id="${playerId}" data-action="increment" class="bg-green-600 w-8 h-8 md:w-10 md:h-10 text-xl md:text-2xl rounded-full">+</button>
                                        </div>
                                    </div>
                                ` : `
                                    <div class="w-full text-center">
                                        <div class="flex items-center justify-between w-full">
                                            <span class="player-name-display font-bold text-gray-400 text-xs md:text-sm">${playerState.name || 'OPPONENT'}</span>
                                            ${myPlayerId === 'p1' ? `<button data-remove-player-id="${playerId}" class="remove-player-btn ml-2 text-red-500 font-bold">X</button>` : ''}
                                        </div>
                                        <span id="${playerId}-hand-size" class="text-xs text-gray-400">Hand: 0</span>
                                    </div>
                                    <div class="flex flex-col items-center">
                                        <input type="number" id="${playerId}-life-total" class="life-total-input text-4xl lg:text-5xl font-bold" value="40" readonly>
                                        <div class="flex gap-1 md:gap-2 mt-2">
                                            <button data-player-id="${playerId}" data-action="decrement" class="bg-red-600 w-8 h-8 md:w-10 md:h-10 text-xl md:text-2xl rounded-full">-</button>
                                            <button data-player-id="${playerId}" data-action="increment" class="bg-green-600 w-8 h-8 md:w-10 md:h-10 text-xl md:text-2xl rounded-full">+</button>
                                        </div>
                                    </div>
                                `}
                            </div>
                        </div>`;
                });
                boardHTML += `</div>`;
                mainGridEl.innerHTML = boardHTML;

                // Use a timeout to ensure the grid has been rendered before we measure it
                setTimeout(() => {
                    orderedPlayerIds.forEach(playerId => {
                        const gridEl = document.getElementById(`${playerId}-battlefield-grid`);
                        calculateAndCreateSlots(gridEl);
                    });
                    // After creating the correct number of slots, we need to re-render to place any existing cards.
                    renderBoard();
                }, 100); // A 100ms delay gives the browser time to render
                
                document.querySelectorAll('.clickable-zone').forEach(el => {
                    const playerId = el.id.split('-')[0];
                    const zoneName = el.id.split('-')[1]; 
                    
                    if (zoneName === 'library' && playerId === myPlayerId) {
                        el.addEventListener('click', drawCard);
                        el.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            showLibraryContextMenu(e);
                        });
                    } else { 
                        el.addEventListener('click', () => openZoneViewer(playerId, zoneName));
                    }
                });
                 const createTokenBtn = document.getElementById('create-token-btn');
                if(createTokenBtn) {
                    createTokenBtn.addEventListener('click', () => tokenCreatorModal.classList.remove('hidden'));
                }
                const passTurnBtn = document.getElementById('passTurnBtn');
                if (passTurnBtn) {
                    passTurnBtn.addEventListener('click', handlePassTurn);
                }
            }

            function drawCard() {
                const playerRef = gameRef.child('players').child(myPlayerId);
                playerRef.transaction(playerState => {
                    if (playerState && playerState.deck && playerState.deck.length > 0) {
                        const cardToDraw = playerState.deck.pop();
                        
                        if (!playerState.hand) playerState.hand = [];
                        playerState.hand.push(cardToDraw);
                    }
                    return playerState;
                });
            }

            function initializeDragAndDrop() {
            sortableInstances.forEach(s => s.destroy());
            sortableInstances = [];
            if (!myPlayerId) return;

            const options = {
                group: 'cards',
                animation: 150,
                ghostClass: 'sortable-ghost',
                dragClass: 'sortable-drag',
                onStart: () => document.body.style.cursor = 'grabbing',
                onEnd: (event) => {
                    document.body.style.cursor = '';
                    handleCardMove(event);
                }
            };

            // This section now iterates over ALL players to make every battlefield a valid drop target.
            if (gameState && gameState.players) {
                Object.keys(gameState.players).forEach(playerId => {
                    const battlefieldGrid = document.getElementById(`${playerId}-battlefield-grid`);
                    if (battlefieldGrid) {
                        battlefieldGrid.querySelectorAll('.grid-slot').forEach(slot => {
                            sortableInstances.push(new Sortable(slot, options));
                        });
                    }
                });
            }

            // This original logic remains, ensuring only YOUR hand and side zones are draggable.
            const handEl = document.getElementById('main-player-hand-cards');
            if (handEl) {
                sortableInstances.push(new Sortable(handEl, options));
            }

            const sideZoneSelectors = [`#${myPlayerId}-graveyard`, `#${myPlayerId}-exile`, `#${myPlayerId}-commander`];
            sideZoneSelectors.forEach(selector => {
                const zoneEl = document.querySelector(selector);
                if (zoneEl) {
                    const container = zoneEl.querySelector('.card-container');
                    if (container) {
                        sortableInstances.push(new Sortable(container, options));
                    }
                }
            });
        }
            
            function handleCardClick(event) {
                if (event.metaKey || event.ctrlKey) return;
                const cardEl = event.currentTarget;
                const instanceId = cardEl.dataset.instanceId;
                const playerRef = gameRef.child('players').child(myPlayerId);

                playerRef.transaction(playerState => {
                    if (playerState && playerState.battlefield) {
                        // NEW LOGIC: Iterate through the grid object to find the card
                        for (const slotId in playerState.battlefield) {
                            const stack = playerState.battlefield[slotId];
                            if (stack && Array.isArray(stack)) {
                                const card = stack.find(c => c && c.instanceId === instanceId);
                                if (card) {
                                    card.tapped = !card.tapped;
                                    // Found the card, no need to look further
                                    return playerState;
                                }
                            }
                        }
                    }
                    return playerState;
                });
            }
            
            function showContextMenu(event) {
                event.preventDefault();
                hideContextMenu();

                const cardEl = event.currentTarget;
                const instanceId = cardEl.dataset.instanceId;
                const parentZoneEl = cardEl.closest('[data-zone-name]');
                let parentZoneName = parentZoneEl ? parentZoneEl.dataset.zoneName : null;
                
                if (cardEl.closest('#library-search-modal')) {
                    parentZoneName = 'deck';
                }

                contextMenuCard = { instanceId, fromZone: parentZoneName };
                const cardData = cardDataMap.get(instanceId);

                if (!cardData) return; // Exit if we can't find card data

                let menuHTML = '';

                // Universal "Counters" Menu for all battlefield cards/tokens
                if (parentZoneName === 'battlefield') {
                    menuHTML += `
                        <div>
                            <button class="context-menu-button" data-action="submenu" data-submenu="counters-menu">Counters</button>
                            <div id="counters-menu" class="context-submenu hidden">
                                ${(cardData.counters && Object.keys(cardData.counters).length > 0)
                                    ? Object.entries(cardData.counters).map(([name, count]) => `
                                        <div class="context-menu-item">
                                            <span class="mr-2 truncate">${decodeFirebaseKey(name)} (${count})</span>
                                            <div class="flex items-center gap-2">
                                                <button data-action="change-counter" data-name="${name}" data-amount="-1" class="flex items-center justify-center bg-gray-600 w-6 h-6 rounded-full">-</button>
                                                <button data-action="change-counter" data-name="${name}" data-amount="1" class="flex items-center justify-center bg-gray-600 w-6 h-6 rounded-full">+</button>
                                            </div>
                                        </div>`).join('')
                                    : '<div class="p-2 text-sm text-gray-400 text-center">No counters</div>'
                                }
                                <div class="context-menu-divider"></div>
                                <div class="p-1">
                                    <input type="text" id="new-counter-name" placeholder="New counter..." class="context-menu-input mb-2">
                                    <button data-action="add-counter" class="w-full bg-indigo-600 text-white text-sm py-1 rounded">Add</button>
                                </div>
                            </div>
                        </div>
                        <div class="context-menu-divider"></div>
                    `;
                }

                // "Move Card" Menu for non-tokens
                if (!cardData.isToken) {
                    menuHTML += `
                        <div>
                            <button class="context-menu-button" data-action="submenu" data-submenu="move-menu">Move Card</button>
                            <div id="move-menu" class="context-submenu hidden">
                                ${['Hand', 'Battlefield', 'Graveyard', 'Exile', 'Commander', 'Library (Top)', 'Library (Bottom)'].map(zone => {
                                    const zoneId = zone.toLowerCase().replace(' (top)','-top').replace(' (bottom)','-bottom');
                                    return `<button class="context-menu-button text-white" data-action="move-to" data-zone="${zoneId}">${zone}</button>`;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }

                // New block for the commander cast count
                if (parentZoneName === 'commander') {
                    menuHTML += `
                        <div class="context-menu-divider"></div>
                        <button class="context-menu-button" data-action="increment-cast-count">+1 Cast Count</button>
                        <button class="context-menu-button" data-action="decrement-cast-count">-1 Cast Count</button>
                    `;
                }

                // "Delete Token" option, only for tokens
                if (cardData.isToken) {
                    menuHTML += `<div><button class="context-menu-button text-white" data-action="delete-token">Delete Token</button></div>`;
                }

                contextMenu.innerHTML = menuHTML;
                contextMenu.classList.remove('hidden');
                // ... positioning logic remains the same ...
                const menuHeight = contextMenu.offsetHeight;
                const menuWidth = contextMenu.offsetWidth;
                let top = event.clientY;
                let left = event.clientX;

                // NEW LOGIC: If the click is in the bottom half of the screen, open the menu upwards.
                if (event.clientY > window.innerHeight / 2) {
                    top = event.clientY - menuHeight;
                }

                // Keep the logic to prevent going off the right edge.
                if (left + menuWidth > window.innerWidth) {
                    left = event.clientX - menuWidth;
                }

                // Keep the logic to prevent going off the top edge.
                if (top < 0) {
                    top = 5; // Small buffer from the top edge
                }

                contextMenu.style.left = `${left}px`;
                contextMenu.style.top = `${top}px`;
            }

            function showLibraryContextMenu(event) {
                hideContextMenu();
                let menuHTML = `
                    <div>
                        <button class="context-menu-button text-white" data-action="draw-opening-hand">Draw Opening Hand</button>
                        <div class="context-menu-divider"></div>
                        <button class="context-menu-button text-white" data-action="search-library">Search</button>
                        <button class="context-menu-button text-white" data-action="shuffle-library">Shuffle</button>
                        <div class="context-menu-divider"></div>
                        <button class="context-menu-button text-white" data-action="scry">Scry</button>
                        <button class="context-menu-button text-white" data-action="surveil">Surveil</button>
                    </div>
                `;
                contextMenu.innerHTML = menuHTML;
                contextMenu.style.left = `${event.clientX}px`;
                contextMenu.style.top = `${event.clientY}px`;
                contextMenu.classList.remove('hidden');
            }

            function hideContextMenu() {
                contextMenu.classList.add('hidden');
                contextMenuCard = null;
            }

            function handleContextMenuClick(event) {
                const button = event.target.closest('button[data-action]');
                if (!button) return;

                const action = button.dataset.action;

                // FIX: Handle submenu toggling
                if (action === 'submenu') {
                    const submenuId = button.dataset.submenu;
                    const submenu = document.getElementById(submenuId);
                    if (submenu) {
                        submenu.classList.toggle('hidden');

                        // FIX: After opening a submenu, check if the whole menu is now off-screen
                        const menuRect = contextMenu.getBoundingClientRect();
                        if (menuRect.bottom > window.innerHeight) {
                            // If it is, move it up by the amount it's overflowing
                            const overflow = menuRect.bottom - window.innerHeight;
                            const newTop = contextMenu.offsetTop - overflow - 10; // 10px buffer
                            contextMenu.style.top = `${newTop}px`;
                        }
                    }
                    return; // Stop further execution
                }

                if (action === 'change-counter') {
                    const name = button.dataset.name;
                    const amount = parseInt(button.dataset.amount, 10);

                    // --- Counters update the menu text automatically ---
                    const counterSpan = button.parentElement.previousElementSibling;
                    if (counterSpan) {
                        let currentCount = parseInt(counterSpan.textContent.match(/\((\d+)\)/)[1], 10);
                        let newCount = currentCount + amount;
                        if (newCount > 0) {
                            counterSpan.textContent = `${decodeFirebaseKey(name)} (${newCount})`;
                        } else {
                            // If the count drops to 0 or below, remove the entire line item
                            counterSpan.parentElement.remove();
                        }
                    }

                    changeCounter(name, amount);
                } else if (action === 'add-counter') {
                    const counterName = document.getElementById('new-counter-name').value.trim();
                    if (counterName) {
                        addNewCounter(counterName);
                    }
                } else if (action === 'move-to') {
                    const toZone = button.dataset.zone;
                    moveCardToZone(toZone);
                } else if (action === 'delete-token') {
                    deleteToken();
                } else if (action === 'increment-cast-count') {
                    handleCastCount(1);
                } else if (action === 'decrement-cast-count') {
                    handleCastCount(-1);    
                } else if (action === 'draw-opening-hand') {
                    handleDrawOpeningHand();    
                } else if (action === 'search-library') {
                    openLibrarySearch();
                } else if (action === 'shuffle-library') {
                    handleShuffleLibrary();
                } else if (action === 'scry') {
                    handleScry();
                } else if (action === 'surveil') {
                    handleSurveil();
                }
                
                // Don't hide the main menu if a counter button was clicked,
                // as the counter submenu should stay open.
                if (action !== 'change-counter' && action !== 'add-counter') {
                    hideContextMenu();
                }
            }

            function changeCounter(encodedCounterName, amount) {
                if (!contextMenuCard) return;
                const playerRef = gameRef.child('players').child(myPlayerId);
                playerRef.transaction(playerState => {
                    if (playerState && playerState.battlefield) {
                        // NEW LOGIC: Iterate through the grid object to find the card
                        for (const slotId in playerState.battlefield) {
                            const stack = playerState.battlefield[slotId];
                            const card = stack ? stack.find(c => c && c.instanceId === contextMenuCard.instanceId) : null;
                            if (card) {
                                if (!card.counters) card.counters = {};
                                if (!card.counters[encodedCounterName]) card.counters[encodedCounterName] = 0;
                                card.counters[encodedCounterName] += amount;
                                if (card.counters[encodedCounterName] <= 0) {
                                    delete card.counters[encodedCounterName];
                                }
                                return playerState; // Exit after finding and modifying
                            }
                        }
                    }
                    return playerState;
                });
            }

            function addNewCounter(counterName) {
                if (!contextMenuCard) return;

                // --- This is your existing, correct UI update logic ---
                const countersMenu = document.getElementById('counters-menu');
                const newCounterNameInput = document.getElementById('new-counter-name');
                const noCountersMessage = countersMenu.querySelector('.text-gray-400');

                // If the "No counters" message is there, remove it
                if (noCountersMessage) {
                    noCountersMessage.remove();
                }

                const encodedNameForUI = encodeFirebaseKey(counterName);
                const newItemHTML = `
                    <div class="context-menu-item">
                        <span class="mr-2 truncate">${counterName} (1)</span>
                        <div class="flex items-center gap-2">
                            <button data-action="change-counter" data-name="${encodedNameForUI}" data-amount="-1" class="flex items-center justify-center bg-gray-600 w-6 h-6 rounded-full">-</button>
                            <button data-action="change-counter" data-name="${encodedNameForUI}" data-amount="1" class="flex items-center justify-center bg-gray-600 w-6 h-6 rounded-full">+</button>
                        </div>
                    </div>`;

                // Insert the new counter before the divider
                const divider = countersMenu.querySelector('.context-menu-divider');
                if (divider) {
                    divider.insertAdjacentHTML('beforebegin', newItemHTML);
                }

                newCounterNameInput.value = ''; // Clear the input box
                // --- End of UI logic ---


                // --- This is the new, corrected database logic ---
                const encodedName = encodeFirebaseKey(counterName);
                const playerRef = gameRef.child('players').child(myPlayerId);
                playerRef.transaction(playerState => {
                    if (playerState && playerState.battlefield) {
                        // NEW LOGIC: Iterate through the grid object to find the card
                        for (const slotId in playerState.battlefield) {
                            const stack = playerState.battlefield[slotId];
                            const card = stack ? stack.find(c => c && c.instanceId === contextMenuCard.instanceId) : null;
                            if (card) {
                                if (!card.counters) card.counters = {};
                                card.counters[encodedName] = (card.counters[encodedName] || 0) + 1;
                                return playerState; // Exit after finding and modifying
                            }
                        }
                    }
                    return playerState;
                });
            }
            
            function moveCardToZone(toZoneId) {
                if (!contextMenuCard) return;
                const { instanceId, fromZone } = contextMenuCard;

                const isLibraryMove = toZoneId.includes('library');
                const toZone = isLibraryMove ? 'deck' : toZoneId.replace('-top','').replace('-bottom','');

                const playerRef = gameRef.child('players').child(myPlayerId);
                playerRef.transaction(playerState => {
                    if (!playerState) return playerState;

                    let cardToMove = null;

                    // --- FIND AND REMOVE THE CARD ---
                    if (fromZone === 'battlefield') {
                        if (playerState.battlefield) {
                            for (const slotId in playerState.battlefield) {
                                const stack = playerState.battlefield[slotId];
                                const cardIndex = stack.findIndex(c => c && c.instanceId === instanceId);
                                if (cardIndex > -1) {
                                    [cardToMove] = stack.splice(cardIndex, 1);
                                    if (stack.length === 0) {
                                        delete playerState.battlefield[slotId];
                                    }
                                    break;
                                }
                            }
                        }
                    } else { // From hand, graveyard, etc.
                        if (playerState[fromZone] && Array.isArray(playerState[fromZone])) {
                            const cardIndex = playerState[fromZone].findIndex(c => c && c.instanceId === instanceId);
                            if (cardIndex > -1) {
                                [cardToMove] = playerState[fromZone].splice(cardIndex, 1);
                            }
                        }
                    }

                    if (cardToMove) {
                        // If the card is leaving the battlefield, clear its state
                        if (fromZone === 'battlefield' && toZone !== 'battlefield') {
                            delete cardToMove.tapped;
                            delete cardToMove.counters;
                        }

                        // --- PLACE THE CARD IN ITS DESTINATION ---
                        if (toZone === 'battlefield') {
                            if (!playerState.battlefield) playerState.battlefield = {};
                            let placed = false;
                            // CORRECTED LOOP: Start at 1 to match data-slot-id
                            for (let i = 1; i <= 40; i++) {
                                if (!playerState.battlefield[i] || playerState.battlefield[i].length === 0) {
                                    playerState.battlefield[i] = [cardToMove];
                                    placed = true;
                                    break;
                                }
                            }
                            // Fallback if battlefield is full
                            if (!placed) {
                                if (!playerState.hand) playerState.hand = [];
                                playerState.hand.push(cardToMove);
                            }
                        } else { // Moving to a non-battlefield zone
                            if (!playerState[toZone]) playerState[toZone] = [];
                            if (isLibraryMove) {
                                if (toZoneId.endsWith('-top')) playerState[toZone].push(cardToMove);
                                else playerState[toZone].unshift(cardToMove);
                            } else {
                                playerState[toZone].push(cardToMove);
                            }
                        }
                    }
                    return playerState;
                });

                hideContextMenu();
                closeZoneViewer();
                closeLibrarySearch();
            }

            function addCardEventListeners() {
                 document.querySelectorAll('.card').forEach(cardEl => {
                    cardEl.removeEventListener('click', handleCardClick);
                    cardEl.removeEventListener('contextmenu', showContextMenu);
                    cardEl.removeEventListener('touchstart', handleTouchStart);
                    cardEl.removeEventListener('touchend', handleTouchEnd);
                    cardEl.removeEventListener('touchmove', handleTouchMove);
                    cardEl.removeEventListener('mouseenter', handleCardMouseOver);
                    cardEl.removeEventListener('mouseleave', handleCardMouseOut);
                    cardEl.removeEventListener('mousemove', handleCardMouseMove);

                    // Determine if the card is in a context where the current player has control
                    const inMyPlayerArea = cardEl.closest(`#player-area-${myPlayerId}, #main-player-hand-area`);
                    const inMyModal = cardEl.closest('#zone-viewer-modal') && zoneViewerContent.dataset.ownerId === myPlayerId;
                    const inMyLibrarySearch = cardEl.closest('#library-search-modal');

                    if (inMyPlayerArea || inMyModal || inMyLibrarySearch) {
                        // These listeners are for actions the player can take on their own cards
                        cardEl.addEventListener('click', handleCardClick);
                        cardEl.addEventListener('contextmenu', showContextMenu);
                        cardEl.addEventListener('touchstart', handleTouchStart);
                        cardEl.addEventListener('touchend', handleTouchEnd);
                        cardEl.addEventListener('touchmove', handleTouchMove);
                    }

                    cardEl.addEventListener('mouseenter', handleCardMouseOver);
                    cardEl.addEventListener('mouseleave', handleCardMouseOut);
                    cardEl.addEventListener('mousemove', handleCardMouseMove);
                });
            }

            function handleTouchStart(e) {
                longPressTimer = setTimeout(() => {
                    e.preventDefault();
                    showContextMenu({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY, currentTarget: e.currentTarget, preventDefault: () => {} });
                }, 500);
            }
            function handleTouchEnd() { clearTimeout(longPressTimer); }
            function handleTouchMove() { clearTimeout(longPressTimer); }

            function parseManaCost(cost) {
                if (!cost) return '';
                const symbolRegex = /\{([^}]+)\}/g;
                return cost.replace(symbolRegex, (match, symbol) => {
                    const sanitizedSymbol = symbol.replace('/', '');
                    return `<img src="https://svgs.scryfall.io/card-symbols/${sanitizedSymbol.toUpperCase()}.svg" alt="${symbol}" class="inline-block w-4 h-4">`;
                });
            }

            function handleCardMouseOver(event) {
                const instanceId = event.currentTarget.dataset.instanceId;
                const cardData = cardDataMap.get(instanceId);

                if (cardData) { // This now runs for any card or token
                    popoutNameEl.textContent = cardData.name;
                    popoutImgEl.src = cardData.imageUrl || 'https://placehold.co/280x200/2d3748/e2e8f0?text=Token';

                    if (cardData.isToken) {
                        // TOKEN LOGIC: Show token-specific info
                        popoutTypeEl.textContent = "Token";
                        if (cardData.subtype) {
                        popoutTypeEl.textContent += ` — ${cardData.subtype}`;
                        }
                        popoutCostEl.innerHTML = ''; // Tokens have no mana cost
                        popoutTextEl.innerHTML = (cardData.text || '').replace(/\n/g, '<br>');
                        popoutFlavourTextEl.style.display = 'none';
                        popoutPtEl.textContent = cardData.pt || '';
                    } else {
                        // REGULAR CARD LOGIC: Use the existing logic
                        popoutCostEl.innerHTML = parseManaCost(cardData.cost);
                        let typeLine = cardData.type || '';
                        if (cardData.subtype) {
                            typeLine += ` — ${cardData.subtype}`;
                        }
                        popoutTypeEl.textContent = typeLine;
                        popoutTextEl.innerHTML = (cardData.text || '').replace(/\n/g, '<br>');

                        if (cardData.flavourText) {
                            popoutFlavourTextEl.innerHTML = (cardData.flavourText || '').replace(/\n/g, '<br>');
                            popoutFlavourTextEl.classList.remove('hidden');
                        } else {
                            popoutFlavourTextEl.classList.add('hidden');
                        }

                        if (cardData.power && cardData.toughness) {
                            popoutPtEl.textContent = `${cardData.power}/${cardData.toughness}`;
                        } else if (cardData.loyalty) {
                            popoutPtEl.textContent = `Loyalty: ${cardData.loyalty}`;
                        } else {
                            popoutPtEl.textContent = '';
                        }
                    }
                    cardPopoutEl.classList.remove('hidden');
                }
            }

            function handleCardMouseOut() {
                cardPopoutEl.classList.add('hidden');
            }

            function handleCardMouseMove(event) {
                const popoutHeight = cardPopoutEl.offsetHeight;
                const popoutWidth = cardPopoutEl.offsetWidth;
                const buffer = 20;

                let top = event.clientY + buffer;
                let left = event.clientX + buffer;

                if (top + popoutHeight > window.innerHeight) {
                    top = event.clientY - popoutHeight - buffer;
                }
                if (top < 0) {
                    top = buffer;
                }
                if (left + popoutWidth > window.innerWidth) {
                    left = event.clientX - popoutWidth - buffer;
                }

                cardPopoutEl.style.left = `${left}px`;
                cardPopoutEl.style.top = `${top}px`;
            }
            
            function handleCardMove(event) {
                const cardEl = event.item;
                const instanceId = cardEl.dataset.instanceId;
                if (!instanceId) return;

                const fromZoneEl = event.from.closest('[data-zone-name]');
                const toZoneEl = event.to.closest('[data-zone-name]');

                if (!fromZoneEl || !toZoneEl) {
                    console.error("Could not determine from/to zone for card move.");
                    return;
                }

                // Get the source and destination player IDs from the board.
                // This defaults to your ID if moving from/to the hand area.
                const sourcePlayerId = event.from.closest('.player-area')?.id.replace('player-area-', '') || myPlayerId;
                const destPlayerId = event.to.closest('.player-area')?.id.replace('player-area-', '') || myPlayerId;

                const fromKey = fromZoneEl.dataset.zoneName;
                const toKey = toZoneEl.dataset.zoneName;
                const fromSlotEl = event.from.closest('.grid-slot');
                const toSlotEl = event.to.closest('.grid-slot');

                // Perform the transaction on the parent 'players' node to handle multiple players.
                const playersRef = gameRef.child('players');
                playersRef.transaction(allPlayersState => {
                    if (!allPlayersState) return allPlayersState;

                    const sourcePlayerState = allPlayersState[sourcePlayerId];
                    const destPlayerState = allPlayersState[destPlayerId];

                    // Safety check: if either player doesn't exist, abort the transaction.
                    if (!sourcePlayerState || !destPlayerState) {
                        console.error("Source or destination player not found.");
                        return; // Abort
                    }

                    let cardToMove = null;

                    // 1. FIND AND REMOVE THE CARD FROM THE SOURCE PLAYER
                    if (fromKey === 'battlefield' && fromSlotEl) {
                        const fromSlotId = fromSlotEl.dataset.slotId;
                        if (sourcePlayerState.battlefield && sourcePlayerState.battlefield[fromSlotId]) {
                            const cardIndex = sourcePlayerState.battlefield[fromSlotId].findIndex(c => c && c.instanceId === instanceId);
                            if (cardIndex > -1) {
                                [cardToMove] = sourcePlayerState.battlefield[fromSlotId].splice(cardIndex, 1);
                                if (sourcePlayerState.battlefield[fromSlotId].length === 0) {
                                    delete sourcePlayerState.battlefield[fromSlotId];
                                }
                            }
                        }
                    } else { // From hand, graveyard, etc.
                        if (sourcePlayerState[fromKey] && Array.isArray(sourcePlayerState[fromKey])) {
                            const cardIndex = sourcePlayerState[fromKey].findIndex(c => c && c.instanceId === instanceId);
                            if (cardIndex > -1) {
                                [cardToMove] = sourcePlayerState[fromKey].splice(cardIndex, 1);
                            }
                        }
                    }

                    if (cardToMove) {
                        // If the card is leaving the battlefield, clear its state.
                        if (fromKey === 'battlefield' && toKey !== 'battlefield') {
                            delete cardToMove.tapped;
                            delete cardToMove.counters;
                        }
                        // 2. PLACE THE CARD IN ITS DESTINATION FOR THE DESTINATION PLAYER
                        if (toKey === 'battlefield' && toSlotEl) {
                            const toSlotId = toSlotEl.dataset.slotId;
                            if (!destPlayerState.battlefield) destPlayerState.battlefield = {};
                            if (!destPlayerState.battlefield[toSlotId]) destPlayerState.battlefield[toSlotId] = [];

                            if (destPlayerState.battlefield[toSlotId].length < 2) {
                                destPlayerState.battlefield[toSlotId].push(cardToMove);
                            } else {
                                // Fallback: If slot is full, return card to owner's hand
                                if (!sourcePlayerState.hand) sourcePlayerState.hand = [];
                                sourcePlayerState.hand.push(cardToMove);
                            }
                        } else { // Moving to a non-battlefield zone (e.g., back to your hand)
                            if (!destPlayerState[toKey]) destPlayerState[toKey] = [];
                            
                            if (fromKey === toKey && sourcePlayerId === destPlayerId) { 
                                destPlayerState[toKey].splice(event.newIndex, 0, cardToMove);
                            } else {
                                destPlayerState[toKey].push(cardToMove);
                            }
                        }
                    }
                    
                    // Return the entire, modified players object to be saved to Firebase.
                    return allPlayersState;
                });
            }

            function handleLifeChange(playerId, action) {
                const playerLifeRef = gameRef.child('players').child(playerId).child('life');
                playerLifeRef.transaction(currentLife => {
                    if (currentLife === null) currentLife = 40;
                    if (action === 'increment' && currentLife < 999) return currentLife + 1;
                    if (action === 'decrement' && currentLife > 0) return currentLife - 1;
                    return currentLife; 
                });
            }

            function handleLifeTextEntry(event) {
                const lifeEl = event.target;
                let newLife = parseInt(lifeEl.value, 10);
                if (isNaN(newLife)) {
                    lifeEl.value = gameState.players[myPlayerId]?.life ?? 40; 
                    return;
                }
                newLife = Math.max(0, Math.min(newLife, 999));
                gameRef.child('players').child(myPlayerId).child('life').set(newLife);
            }
            
            function openZoneViewer(playerId, zoneName, cardsToShow = null) {
                if (modalSortable) modalSortable.destroy();

                // Get a reference to the new info icon at the start
                const infoIcon = document.getElementById('commander-info-icon');

                const playerState = gameState.players[playerId];
                if (!playerState) return;
                
                // Show or hide the icon based on the zone
                if (zoneName === 'commander' && playerId === myPlayerId) {
                    infoIcon.style.display = 'inline-block';
                } else {
                    infoIcon.style.display = 'none';
                }

                const actualZoneName = zoneName === 'library' ? 'deck' : zoneName;
                const cards = cardsToShow !== null ? cardsToShow : (playerState[actualZoneName] || []);

                const ownerName = playerId === myPlayerId ? 'Your' : `${playerState.name}'s`;
                zoneViewerTitle.textContent = `${ownerName} ${zoneName.charAt(0).toUpperCase() + zoneName.slice(1)}`;
                zoneViewerContent.innerHTML = '';
                zoneViewerContent.dataset.zoneName = zoneName;
                zoneViewerContent.dataset.ownerId = playerId;

                
                if (cards.length === 0) {
                    zoneViewerContent.innerHTML = '<p class="text-gray-500">This zone is empty.</p>';
                } else {
                    cards.slice().reverse().forEach(card => {
                        const cardEl = createCardElement(card);
                        zoneViewerContent.appendChild(cardEl);
                    });
                }
                
                zoneViewerModal.classList.remove('hidden');
                
                addCardEventListeners(); 

                if (playerId === myPlayerId && cardsToShow === null) {
                    modalSortable = new Sortable(zoneViewerContent, {
                        group: 'cards',
                        animation: 150,
                        ghostClass: 'sortable-ghost',
                        dragClass: 'sortable-drag',
                        onStart: () => document.body.style.cursor = 'grabbing',
                        // The original, correct logic is restored here
                        onEnd: (event) => {
                            document.body.style.cursor = '';
                            handleCardMove(event);
                        }
                    });
                }
            }

            function closeZoneViewer() {
                if (modalSortable) modalSortable.destroy();
                modalSortable = null;
                zoneViewerModal.classList.add('hidden');
                finishInteractiveBtn.classList.add('hidden');
                interactiveActionState.active = false;
            }

            function closeOpeningHandModal() {
                const modal = document.getElementById('opening-hand-modal');
                if (modal) {
                    modal.classList.add('hidden');
                }
                pendingOpeningHand = []; // Clear the temporary hand
            }
            
            function showDeckSelectionModal(playerId) { // It now accepts a playerId
                const savedDecks = JSON.parse(localStorage.getItem('savedDecks')) || {};
                deckSelectionList.innerHTML = '';

                if (Object.keys(savedDecks).length === 0) {
                    deckSelectionList.innerHTML = `
                        <p class="text-gray-400">No saved decks found.</p>
                    `;
                } else {
                    for (const deckName in savedDecks) {
                        const button = document.createElement('button');
                        button.className = 'deck-select-button';
                        button.textContent = deckName;
                        button.addEventListener('click', () => {
                            const playerName = document.getElementById('joiningPlayerName').value.trim();
                            if (!playerName) {
                                alert("Please enter your name.");
                                return;
                            }
                            const deckData = savedDecks[deckName];
                            const cardIds = deckData.cardIds || deckData;
                            const commanderIds = deckData.commanderIds || [];
                            const fullDeck = cardIds.map(id => allCardsFromDb.find(card => card.id === id)).filter(Boolean);
                            const commanders = commanderIds.map(id => allCardsFromDb.find(card => card.id === id)).filter(Boolean);
                            // This now correctly calls the function from Step 1 with the new signature
                            loadDeckForPlayer(fullDeck, commanders, playerName, playerId);
                        });
                        deckSelectionList.appendChild(button);
                    }
                }
                
                const deckbuilderLink = document.createElement('a');
                deckbuilderLink.href = 'deckbuilder.html';
                deckbuilderLink.className = 'mt-4 block text-center w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg';
                deckbuilderLink.textContent = 'Go to Deckbuilder';
                deckSelectionList.appendChild(deckbuilderLink);

                deckSelectionModal.classList.remove('hidden');
            }

            function loadDeckForPlayer(deck, commanders, playerName, playerId) {
                if (!playerId || !deck) return;
                shuffle(deck);

                deck.forEach(card => {
                    card.instanceId = `card-${Date.now()}-${Math.random()}`;
                    card.ownerId = playerId; // Use the 'playerId' parameter to assign owner
                });

                commanders.forEach(c => {
                    if (!c.instanceId) c.instanceId = `card-${Date.now()}-${Math.random()}`;
                    c.ownerId = playerId; // Use the 'playerId' parameter to assign owner
                    c.castCount = 0;
                });
                
                gameRef.child('players').child(playerId).update({
                    name: playerName,
                    deck: deck,
                    commander: commanders,
                    deckLoaded: true
                });
                deckSelectionModal.classList.add('hidden');
            }
            
            function createToken(tokenData) {
                const playerRef = gameRef.child('players').child(myPlayerId);
                playerRef.transaction(playerState => {
                    if (playerState) {
                        if (!playerState.battlefield) playerState.battlefield = {}; // Ensure battlefield is an object

                        const newToken = {
                            ...tokenData,
                            isToken: true,
                            instanceId: `token-${Date.now()}-${Math.random()}`
                        };

                        // Find the first available empty slot in the grid
                        let placed = false;
                        for (let i = 1; i < 40; i++) { // Check up to 40 slots
                            if (!playerState.battlefield[i] || playerState.battlefield[i].length === 0) {
                                playerState.battlefield[i] = [newToken]; // Place it in a new stack
                                placed = true;
                                break;
                            }
                        }

                        if (!placed) {
                            // This is a fallback in case the board is somehow full
                            console.error("Battlefield is full, cannot create token.");
                        }
                    }
                    return playerState;
                });
                tokenCreatorModal.classList.add('hidden');
            }
            
            function deleteToken() {
                if (!contextMenuCard) return;
                const { instanceId } = contextMenuCard;
                const playerRef = gameRef.child('players').child(myPlayerId);
                playerRef.transaction(playerState => {
                    if (playerState && playerState.battlefield) {
                        // NEW LOGIC: Iterate through the grid object to find the token
                        for (const slotId in playerState.battlefield) {
                            const stack = playerState.battlefield[slotId];
                            if (stack && Array.isArray(stack)) {
                                const cardIndex = stack.findIndex(c => c && c.instanceId === instanceId);
                                if (cardIndex > -1) {
                                    stack.splice(cardIndex, 1);
                                    if (stack.length === 0) {
                                        delete playerState.battlefield[slotId];
                                    }
                                    return playerState; // Exit after finding and deleting
                                }
                            }
                        }
                    }
                    return playerState;
                });
                hideContextMenu();
            }

            function handleCastCount(amount) {
                if (!contextMenuCard) return;
                const instanceId = contextMenuCard.instanceId;
                const playerRef = gameRef.child('players').child(myPlayerId);
                playerRef.transaction(playerState => {
                    if (playerState && playerState.commander) {
                        const card = playerState.commander.find(c => c && c.instanceId === instanceId);
                        if (card) {
                            if (card.castCount === undefined) card.castCount = 0;
                            card.castCount = Math.max(0, card.castCount + amount);
                        }
                    }
                    return playerState;
                });
            }

            function handleRemovePlayer(playerIdToRemove) {
                gameRef.child('players').child(playerIdToRemove).remove();
            }

            // --- Library Functions ---
            function openLibrarySearch() {
                const playerState = gameState.players[myPlayerId];
                if (!playerState || !playerState.deck) return;
                
                librarySearchContent.innerHTML = '';
                playerState.deck.slice().reverse().forEach(card => {
                    const cardEl = createCardElement(card);
                    librarySearchContent.appendChild(cardEl);
                });
                
                addCardEventListeners();
                librarySearchModal.classList.remove('hidden');
            }

            function closeLibrarySearch() {
                librarySearchModal.classList.add('hidden');
                librarySearchInput.value = '';
            }

            function filterLibrary() {
                const searchTerm = librarySearchInput.value.toLowerCase();
                librarySearchContent.querySelectorAll('.card').forEach(cardEl => {
                    const cardData = cardDataMap.get(cardEl.dataset.instanceId);
                    if (cardData) {
                        const isVisible = cardData.name.toLowerCase().includes(searchTerm);
                        cardEl.style.display = isVisible ? '' : 'none';
                    }
                });
            }

            function handleShuffleLibrary() {
                const playerRef = gameRef.child('players').child(myPlayerId);
                return playerRef.transaction(playerState => {
                    if (playerState && playerState.deck) {
                        shuffle(playerState.deck);
                    }
                    return playerState;
                });
            }

            function handleScry() {
                const countStr = prompt("Scry how many cards?");
                if (countStr) {
                    const count = parseInt(countStr, 10);
                    if (!isNaN(count) && count > 0) {
                        openInteractiveZoneViewer('scry', count);
                    }
                }
            }

            function handleSurveil() {
                const countStr = prompt("Surveil how many cards?");
                if (countStr) {
                    const count = parseInt(countStr, 10);
                    if (!isNaN(count) && count > 0) {
                        openInteractiveZoneViewer('surveil', count);
                    }
                }
            }

            const handleDrawOpeningHand = () => {
                const playerState = gameState.players[myPlayerId];

                if (playerState && playerState.deck && playerState.deck.length >= 7) {
                    const openingHand = playerState.deck.slice(-7);
                    const landCount = openingHand.filter(card => card && card.type && card.type.includes('Land')).length;
                    showOpeningHandModal(landCount, openingHand);
                } else {
                    alert("You need at least 7 cards in your library to draw an opening hand.");
                }
            };

            // Draw opening hand modal functions
            function showOpeningHandModal(landCount, hand) {
                pendingOpeningHand = hand; // Store the hand globally
                const modal = document.getElementById('opening-hand-modal');
                const messageEl = document.getElementById('opening-hand-message');
                messageEl.textContent = `Your opening hand contains ${landCount} lands.`;
                modal.classList.remove('hidden');
            }

            function handleKeepHand() {
                const playerRef = gameRef.child('players').child(myPlayerId);
                playerRef.transaction(playerState => {
                    if (playerState && playerState.deck && playerState.deck.length >= 7) {
                        playerState.deck.splice(-7, 7); // Remove top 7 from deck
                        if (!playerState.hand) playerState.hand = [];
                        playerState.hand.push(...pendingOpeningHand);
                    }
                    return playerState;
                });
                closeOpeningHandModal();
            }

            async function handleMulligan() {
                // First, tell the library to shuffle and wait for it to finish.
                await handleShuffleLibrary();

                // The game state will update automatically after the shuffle.
                // Now, re-run the draw hand logic to show the new top 7 cards.
                handleDrawOpeningHand();
            }
            
            function openInteractiveZoneViewer(mode, count) {
                const playerState = gameState.players[myPlayerId];
                const deck = playerState.deck || [];
                
                interactiveActionState = {
                    active: true,
                    mode: mode,
                    count: Math.min(count, deck.length),
                    cards: deck.slice(-count),
                    toTop: [],
                    toBottom: [],
                    toGraveyard: []
                };

                zoneViewerTitle.textContent = `${mode.charAt(0).toUpperCase() + mode.slice(1)} ${interactiveActionState.count}`;
                zoneViewerContent.innerHTML = '';
                
                interactiveActionState.cards.slice().reverse().forEach(card => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'interactive-card-wrapper';
                    wrapper.dataset.instanceId = card.instanceId;

                    const cardEl = createCardElement(card);

                    cardEl.addEventListener('mouseenter', (e) => handleCardMouseOver(e));
                    cardEl.addEventListener('mouseleave', handleCardMouseOut);
                    cardEl.addEventListener('mousemove', handleCardMouseMove);

                    wrapper.appendChild(cardEl);

                    const buttonContainer = document.createElement('div');
                    buttonContainer.className = 'flex justify-around mt-1';
                    
                    const topBtn = document.createElement('button');
                    topBtn.textContent = 'Top';
                    topBtn.className = 'action-button bg-blue-600';
                    topBtn.onclick = () => resolveInteractiveCard(card, 'top');
                    
                    const bottomBtn = document.createElement('button');
                    bottomBtn.className = 'action-button';
                    
                    if (mode === 'scry') {
                        bottomBtn.textContent = 'Bottom';
                        bottomBtn.className += ' bg-gray-600';
                        bottomBtn.onclick = () => resolveInteractiveCard(card, 'bottom');
                    } else { // surveil
                        bottomBtn.textContent = 'Graveyard';
                        bottomBtn.className += ' bg-red-600';
                        bottomBtn.onclick = () => resolveInteractiveCard(card, 'graveyard');
                    }
                    
                    buttonContainer.appendChild(topBtn);
                    buttonContainer.appendChild(bottomBtn);
                    wrapper.appendChild(buttonContainer);
                    zoneViewerContent.appendChild(wrapper);
                });

                zoneViewerModal.classList.remove('hidden');
            }

            function resolveInteractiveCard(card, destination) {
                const wrapper = zoneViewerContent.querySelector(`[data-instance-id="${card.instanceId}"]`);
                if (wrapper) {
                    wrapper.style.display = 'none';
                }

                if (destination === 'top') interactiveActionState.toTop.push(card);
                else if (destination === 'bottom') interactiveActionState.toBottom.push(card);
                else if (destination === 'graveyard') interactiveActionState.toGraveyard.push(card);
                
                const remainingCards = interactiveActionState.cards.length - (interactiveActionState.toTop.length + interactiveActionState.toBottom.length + interactiveActionState.toGraveyard.length);
                if (remainingCards === 0) {
                    finishInteractiveBtn.classList.remove('hidden');
                }
            }

            function finishInteractiveAction() {
                const playerRef = gameRef.child('players').child(myPlayerId);
                playerRef.transaction(playerState => {
                    if (playerState && playerState.deck) {
                        const originalDeckSize = playerState.deck.length;
                        const restOfDeck = playerState.deck.slice(0, originalDeckSize - interactiveActionState.count);
                        
                        const newDeck = [
                            ...interactiveActionState.toBottom,
                            ...restOfDeck, 
                            ...interactiveActionState.toTop.reverse()
                        ];
                        playerState.deck = newDeck;

                        if (interactiveActionState.toGraveyard.length > 0) {
                            if (!playerState.graveyard) playerState.graveyard = [];
                            playerState.graveyard.push(...interactiveActionState.toGraveyard);
                        }
                    }
                    return playerState;
                });
                closeZoneViewer();
            }

            function leaveGame() {
                if (myPlayerId && gameRef) {
                    gameRef.child('players').child(myPlayerId).remove()
                        .then(() => {
                            window.location.href = 'index.html';
                        })
                        .catch(error => {
                            console.error("Error leaving game:", error);
                            window.location.href = 'index.html';
                        });
                } else {
                    window.location.href = 'index.html';
                }
            }

            function handlePassTurn() {
                gameRef.transaction(currentGameState => {
                    if (currentGameState && currentGameState.players && currentGameState.turnOrder) {
                        const oldTurnOrder = currentGameState.turnOrder;
                        const currentPlayerId = oldTurnOrder[currentGameState.currentPlayerIndex];

                        const newPlayerIds = Object.keys(currentGameState.players).sort();
                        currentGameState.turnOrder = newPlayerIds;

                        if (newPlayerIds.length > 0) {
                            const currentTurnIndex = newPlayerIds.indexOf(currentPlayerId);
                            
                            let nextPlayerIndex;
                            if (currentTurnIndex === -1) {
                                nextPlayerIndex = currentGameState.currentPlayerIndex % newPlayerIds.length;
                            } else {
                                nextPlayerIndex = (currentTurnIndex + 1) % newPlayerIds.length;
                            }
                            currentGameState.currentPlayerIndex = nextPlayerIndex;
                        }
                    }
                    return currentGameState;
                });
            }

            function handleDiceRoll() {
                const d20Icon = document.getElementById('d20-icon');
                const d20ResultEl = document.getElementById('d20-result');
                if (!d20Icon || !d20ResultEl) return;

                // Animate the dice
                d20Icon.classList.add('dice-rolling');

                // Temporarily show random numbers for a flashing effect
                let flashes = 0;
                const flashInterval = setInterval(() => {
                    d20ResultEl.textContent = Math.floor(Math.random() * 20) + 1;
                    flashes++;
                    if (flashes > 10) { // Stop after 10 flashes (500ms)
                        clearInterval(flashInterval);

                        // Show the final, true result
                        const finalResult = Math.floor(Math.random() * 20) + 1;
                        d20ResultEl.textContent = finalResult;

                        // Send the result to the chat for everyone to see
                        const playerName = gameState.players[myPlayerId]?.name || 'Player';
                        const message = {
                            sender: 'Game',
                            text: `${playerName} rolled a ${finalResult} on a d20.`,
                            timestamp: firebase.database.ServerValue.TIMESTAMP
                        };
                        gameRef.child('chat').push(message);
                    }
                }, 50);

                // Remove the animation class after it finishes
                setTimeout(() => {
                    d20Icon.classList.remove('dice-rolling');
                }, 500);
            }

            const handleUntapAll = () => {
                const playerRef = gameRef.child('players').child(myPlayerId);
                playerRef.transaction(playerState => {
                    if (playerState && playerState.battlefield) {
                        // NEW LOGIC: Iterate through the grid object and the stacks
                        Object.values(playerState.battlefield).forEach(stack => {
                            if (Array.isArray(stack)) {
                                stack.forEach(card => {
                                    if (card) {
                                        card.tapped = false;
                                    }
                                });
                            }
                        });
                    }
                    return playerState;
                });
            };

            function handleSendMessage(event) {
                if (event.key === 'Enter') {
                    const messageText = chatInputEl.value.trim();
                    if (messageText && gameState.players && gameState.players[myPlayerId]) {
                        const message = {
                            sender: gameState.players[myPlayerId].name || 'Player',
                            text: messageText,
                            timestamp: firebase.database.ServerValue.TIMESTAMP
                        };
                        gameRef.child('chat').push(message);
                        chatInputEl.value = '';
                    }
                }
            }

            function renderChatMessage(message) {
                const msgEl = document.createElement('div');
                msgEl.innerHTML = `<strong>${message.sender}:</strong> ${message.text}`;
                chatMessagesEl.appendChild(msgEl);
                chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight; // Auto-scroll
            }

            async function initializeGame() {
                const changeBackgroundBtn = document.getElementById('changeBackgroundBtn');
                const backgroundUploader = document.getElementById('background-uploader');

                // Function to apply a background image
                const applyBackground = (imageUrl) => {
                    document.body.style.backgroundImage = `url(${imageUrl})`;
                    document.body.style.backgroundSize = 'cover';
                    document.body.style.backgroundPosition = 'center';
                    document.body.style.backgroundRepeat = 'no-repeat';
                };

                // On load, check for a saved background
                const savedBackground = localStorage.getItem('customGameBoardBackground');
                if (savedBackground) {
                    applyBackground(savedBackground);
                }

                // Listener for the new button
                changeBackgroundBtn.addEventListener('click', () => {
                    backgroundUploader.click();
                });

                // Listener for when a file is selected
                backgroundUploader.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (!file || !file.type.startsWith('image/')) {
                        return; // Ensure it's an image file
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const imageUrl = e.target.result;
                        applyBackground(imageUrl);
                        // Save the image to local storage for persistence
                        localStorage.setItem('customGameBoardBackground', imageUrl);
                    };
                    reader.readAsDataURL(file);
                });
            // --- EVENT LISTENERS ---
            contextMenu.addEventListener('click', handleContextMenuClick);
            window.addEventListener('click', (e) => {
                if (!contextMenu.contains(e.target) && !e.target.closest('.card') && !e.target.closest('.clickable-zone')) {
                    hideContextMenu();
                }
            });
            window.addEventListener('contextmenu', (e) => {
                const target = e.target;
                if (!target.closest('.card') && !target.closest(`#${myPlayerId}-library`)) {
                    hideContextMenu();
                }
            });
            mainGridEl.addEventListener('click', (event) => {
                
                const diceRoller = event.target.closest('#dice-roller');
                if (diceRoller) {
                    handleDiceRoll();
                    return;
                }

                const removeButton = event.target.closest('.remove-player-btn');
                if (removeButton) {
                    const playerIdToRemove = removeButton.dataset.removePlayerId;
                    if (playerIdToRemove) {
                        handleRemovePlayer(playerIdToRemove);
                    }
                    return;
                }
                const button = event.target.closest('button[data-player-id]');
                    if (button && button.dataset.playerId === myPlayerId) {
                        handleLifeChange(button.dataset.playerId, button.dataset.action);
                    }
                });
            mainGridEl.addEventListener('change', (event) => {
                if (event.target.id === `${myPlayerId}-life-total`) {
                    handleLifeTextEntry(event);
                }
            });
            zoneViewerClose.addEventListener('click', closeZoneViewer);
            zoneViewerModal.addEventListener('click', (e) => {
                if (e.target === zoneViewerModal) closeZoneViewer();
            });
            librarySearchClose.addEventListener('click', closeLibrarySearch);
            librarySearchInput.addEventListener('input', filterLibrary);
            finishInteractiveBtn.addEventListener('click', finishInteractiveAction);
            leaveGameBtn.addEventListener('click', leaveGame);

            // Chat Logic
            chatToggleButton.addEventListener('click', () => {
                document.body.dataset.chatState = 'open';
                chatNotification.classList.add('hidden');
                chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
            });
            chatMinimizeButton.addEventListener('click', () => {
                document.body.dataset.chatState = 'closed';
            });
            chatInputEl.addEventListener('keydown', handleSendMessage);

            // ADD THIS BLOCK FOR INITIAL CALCULATION
            setTimeout(() => {
                if (gameState && gameState.players) {
                    Object.keys(gameState.players).forEach(playerId => {
                        const gridEl = document.getElementById(`${playerId}-battlefield-grid`);
                        calculateAndCreateSlots(gridEl);
                    });
                    renderBoard();
                }
            }, 100); // A 100ms delay gives the browser time to render

            // ADD THIS BLOCK FOR RESIZING
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (gameState && gameState.players) {
                        Object.keys(gameState.players).forEach(playerId => {
                            const gridEl = document.getElementById(`${playerId}-battlefield-grid`);
                            calculateAndCreateSlots(gridEl);
                        });
                        renderBoard();
                    }
                }, 250);
            });

            untapAllBtn.addEventListener('click', handleUntapAll);

            // Draw opening hand event listeners
            keepHandBtn.addEventListener('click', handleKeepHand);
            mulliganBtn.addEventListener('click', handleMulligan);
            openingHandCancelBtn.addEventListener('click', closeOpeningHandModal);

            // Token Creator Logic
            const tokenCreateBtn = document.getElementById('token-creator-create');
            const tokenCancelBtn = document.getElementById('token-creator-cancel');
            const commonTokenSelect = document.getElementById('common-token-select');
            tokenCancelBtn.addEventListener('click', () => tokenCreatorModal.classList.add('hidden'));
            tokenCreateBtn.addEventListener('click', () => {
                const name = document.getElementById('token-name').value;
                const pt = document.getElementById('token-pt').value;
                const text = document.getElementById('token-text').value;
                if(name) {
                    createToken({ name, pt, text });
                    document.getElementById('token-name').value = '';
                    document.getElementById('token-pt').value = '';
                    document.getElementById('token-text').value = '';
                }
            });
            commonTokenSelect.addEventListener('change', (e) => {
                const selected = e.target.value;
                if(!selected) return;
                let tokenData = {};
                switch(selected) {
                    case 'Treasure':
                    tokenData = { 
                        name: 'Treasure', 
                        text: '{T}, Sacrifice this artifact: Add one mana of any color.',
                        imageUrl: COMMON_TOKEN_IMAGES['Treasure']
                    };
                    break;
                    case 'Food':
                    tokenData = { 
                        name: 'Food', 
                        text: '{2}, {T}, Sacrifice this artifact: You gain 3 life.',
                        imageUrl: COMMON_TOKEN_IMAGES['Food']
                    };
                    break;
                    case 'Clue':
                    tokenData = { 
                        name: 'Clue', 
                        text: '{2}, Sacrifice this artifact: Draw a card.',
                        imageUrl: COMMON_TOKEN_IMAGES['Clue']
                    };
                    break;
                    case '1/1 Human':
                    tokenData = { 
                        name: 'Human',
                        pt: '1/1',
                        imageUrl: COMMON_TOKEN_IMAGES['1/1 Human']
                    };
                    break;
                    case '1/1 Goblin':
                    tokenData = { 
                        name: 'Goblin',
                        pt: '1/1',
                        imageUrl: COMMON_TOKEN_IMAGES['1/1 Goblin']
                    };
                    break;
                    case '1/1 Elf Warrior':
                    tokenData = { 
                        name: 'Elf Warrior',
                        pt: '1/1',
                        imageUrl: COMMON_TOKEN_IMAGES['1/1 Elf Warrior']
                    };
                    break;
                    case '2/2 Zombie':
                    tokenData = { 
                        name: 'Zombie',
                        pt: '2/2',
                        imageUrl: COMMON_TOKEN_IMAGES['2/2 Zombie']
                    };
                    break;
                }
                if (Object.keys(tokenData).length > 0) {
                    createToken(tokenData);
                }
                e.target.value = "";
            });

            // --- AUTHENTICATION AND GAME SETUP ---
            firebase.auth().onAuthStateChanged(async (user) => {
                if (user) {
                    // User is signed in, proceed with game setup.
                    myUserId = user.uid;
                    try {
                        const urlParams = new URLSearchParams(window.location.search);
                        gameId = urlParams.get('gameId');
                        gameIdDisplayEl.textContent = gameId;

                        if (!gameId) {
                            document.body.innerHTML = '<h1 class="text-red-500 text-2xl p-8">Error: No game ID provided.</h1>';
                            return;
                        }
                        gameRef = realdb.ref(`games/${gameId}`);

                        const snapshot = await db.collection('cards').get();
                        allCardsFromDb = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                        const { committed, snapshot: finalSnapshot } = await gameRef.transaction(currentGameState => {
                            if (currentGameState) {
                                let isAlreadyInGame = false;
                                let localPlayerId = null;
                                if (currentGameState.players) {
                                    Object.entries(currentGameState.players).forEach(([pId, pData]) => {
                                        if (pData && pData.uid === myUserId) {
                                            isAlreadyInGame = true;
                                            localPlayerId = pId;
                                        }
                                    });
                                } else {
                                    currentGameState.players = {};
                                }

                                const pendingData = JSON.parse(localStorage.getItem('pendingJoinData'));

                                // PATH 1: A player is re-joining and needs their deck loaded from localStorage.
                                if (isAlreadyInGame && pendingData && currentGameState.players[localPlayerId] && !currentGameState.players[localPlayerId].deckLoaded) {
                                    const playerToUpdate = currentGameState.players[localPlayerId];
                                    playerToUpdate.name = pendingData.playerName;
                                    const deck = JSON.parse(JSON.stringify(pendingData.deck));
                                    shuffle(deck);
                                    // CRITICAL FIX: Assign ownerId to re-joining player's cards.
                                    deck.forEach(card => { 
                                        card.instanceId = `card-${Date.now()}-${Math.random()}`;
                                        card.ownerId = localPlayerId; // Use the correct localPlayerId
                                    });
                                    if(pendingData.commanders) {
                                        // CRITICAL FIX: Assign ownerId to re-joining player's commanders.
                                        pendingData.commanders.forEach(card => { 
                                            card.instanceId = `card-${Date.now()}-${Math.random()}`;
                                            card.ownerId = localPlayerId; // Use the correct localPlayerId
                                        });
                                    }
                                    playerToUpdate.deck = deck;
                                    playerToUpdate.commander = pendingData.commanders;
                                    playerToUpdate.deckLoaded = true;
                                    localStorage.removeItem('pendingJoinData');
                                } 
                                // PATH 2: A brand new player is joining.
                                else if (!isAlreadyInGame) {
                                    const p1 = currentGameState.players.p1;
                                    const openSlot = ['p2', 'p3', 'p4'].find(slot => !currentGameState.players[slot]);
                                    if (openSlot) {
                                        localPlayerId = openSlot;
                                        const startingLife = p1 ? p1.life : 40;
                                        const playerIndex = parseInt(openSlot.slice(1), 10) - 1;
                                        const assignedColor = PLAYER_COLORS[playerIndex];
                                        
                                        // This logic for creating an empty slot is correct from your file.
                                        // The ownerId will be assigned later by loadDeckForPlayer.
                                        currentGameState.players[openSlot] = { 
                                            uid: myUserId, name: `Player ${openSlot.slice(1)}`, life: startingLife, 
                                            color: assignedColor,
                                            deck: [], hand: [], battlefield: [], graveyard:[], exile:[], commander:[], deckLoaded: false 
                                        };
                                    }
                                }

                                const playerIds = Object.keys(currentGameState.players).sort();
                                currentGameState.turnOrder = playerIds;
                                if (currentGameState.currentPlayerIndex === undefined || currentGameState.currentPlayerIndex >= playerIds.length) {
                                    currentGameState.currentPlayerIndex = 0;
                                }

                                // PATH 3: The Host (Player 1) is initializing their own game.
                                const p1 = currentGameState.players.p1;
                                if (localPlayerId === 'p1' && p1) {
                                    // Assign color to Player 1 if it doesn't exist
                                    if (!p1.color) {
                                        p1.color = PLAYER_COLORS[0];
                                    }
                                    if (p1.deck && !p1.shuffled) {
                                        const deck = JSON.parse(JSON.stringify(p1.deck || []));
                                        shuffle(deck);
                                        // CRITICAL FIX: Assign ownerId to P1's cards.
                                        deck.forEach(card => { 
                                            card.instanceId = `card-${Date.now()}-${Math.random()}`; 
                                            card.ownerId = 'p1';
                                        });
                                        p1.deck = deck;
                                        p1.shuffled = true;
                                    }
                                    if (p1.commander && p1.commander.length > 0) {
                                        // CRITICAL FIX: Assign ownerId to P1's commanders.
                                        p1.commander.forEach(c => {
                                            if (!c.instanceId) c.instanceId = `card-${Date.now()}-${Math.random()}`;
                                            c.ownerId = 'p1'; 
                                            if (c.castCount === undefined) c.castCount = 0;
                                        });
                                    }
                                }
                            }
                            return currentGameState;
                        });

                        if (committed) {
                            const newGameState = finalSnapshot.val();
                            if (newGameState) {
                                gameState = newGameState;
                                if (gameState.players) {
                                    Object.entries(gameState.players).forEach(([pId, pData]) => {
                                        if (pData && pData.uid === myUserId) {
                                            myPlayerId = pId;
                                        }
                                    });
                                }
                                renderBoard();
                            }
                            gameRef.on('value', (snapshot) => {
                                const newGameState = snapshot.val();
                                if (newGameState) {
                                    gameState = newGameState;
                                     if (gameState.players) {
                                        Object.entries(gameState.players).forEach(([pId, pData]) => {
                                            if (pData && pData.uid === myUserId) {
                                                myPlayerId = pId;
                                            }
                                        });
                                    }
                                    renderBoard();
                                }
                            });
                        }

                        // CHAT LISTENER
                        const chatRef = gameRef.child('chat');
                        chatRef.on('child_added', (snapshot) => {
                            const message = snapshot.val();
                            renderChatMessage(message);
                            if (document.body.dataset.chatState === 'closed') {
                                chatNotification.classList.remove('hidden');
                            }
                        });

                    } catch (error) {
                        console.error("Initialization failed:", error);
                        document.body.innerHTML = '<h1 class="text-red-500 text-2xl p-8">Error: Could not connect to the server.</h1>';
                    }
                } else {
                    // No user is signed in. Redirect to the login page.
                    window.location.href = 'index.html';
                }
            });
        }
            
            initializeGame();
        });
    </script>
</body>
</html>
