<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deckbuilding Tool</title>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="firebase-init.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <!-- JSZip for handling zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .card-image-sm { width: 100px; height: 140px; }
        .card-preview-img {
            width: 100px;
            height: 140px;
            object-fit: cover;
            border-radius: 0.375rem; /* rounded-md */
        }
        .tab-button.active {
            background-color: #4f46e5;
            color: white;
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .deck-item.commander {
            color: #a5b4fc;
            font-weight: bold;
        }
        /* NEW: Styles for the detailed card pop-out */
        #card-popout {
            position: fixed;
            width: 280px;
            background-color: #1f2937;
            border: 1px solid #4f46e5;
            z-index: 9000;
            color: white;
            display: none; /* This keeps it hidden initially */
            pointer-events: none; /* This is crucial so the pop-out doesn't interfere with mouse events */
        }
        #popout-img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            background-color: #374151;
        }
        #popout-flavour {
            font-style: italic;
            border-top: 1px solid #4b5563;
            padding-top: 8px;
            margin-top: 8px;
        }
        /* NEW: Styles for color pips */
        .color-pip {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 3px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .pip-W { background-color: #f9faf4; }
        .pip-U { background-color: #aae0fa; }
        .pip-B { background-color: #cbc2bf; }
        .pip-R { background-color: #f9aa8f; }
        .pip-G { background-color: #9bd3ae; }
        .pip-M { background: linear-gradient(135deg, #f9aa8f 25%, #aae0fa 25%, #aae0fa 50%, #9bd3ae 50%, #9bd3ae 75%, #cbc2bf 75%); }
        .pip-C { background-color: #cec8c3; }
    </style>
</head>
<body class="bg-gray-800 text-white p-4 md:p-8">

    <h1 class="text-3xl font-bold mb-6 text-indigo-400">Project Card Arena: Deckbuilder</h1>

    <div class="mb-4 border-b border-gray-700">
        <nav class="flex space-x-4" aria-label="Tabs">
            <button id="tab-btn-create" class="tab-button active px-3 py-2 font-medium text-sm rounded-t-lg">Create/Edit Card</button>
            <button id="tab-btn-import" class="tab-button px-3 py-2 font-medium text-sm rounded-t-lg">Bulk Import</button>
            <button id="tab-btn-scryfall" class="tab-button px-3 py-2 font-medium text-sm rounded-t-lg">Scryfall Import</button>
        </nav>
    </div>

    <div>
        <!-- Create/Edit Tab -->
        <div id="tab-content-create" class="tab-content active">
             <div class="bg-gray-900 p-6 rounded-lg shadow-lg">
                <h2 id="form-title" class="text-xl font-semibold mb-4">Create New Card</h2>
                <form id="addCardForm">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label for="cardName" class="block text-sm font-medium text-gray-400">Card Name</label>
                            <input type="text" id="cardName" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                        <div>
                            <label for="cardImage" class="block text-sm font-medium text-gray-400">Card Image (Optional)</label>
                            <input type="file" id="cardImage" accept="image/*" class="mt-1 block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-700">
                        </div>
                        <div>
                            <label for="cardType" class="block text-sm font-medium text-gray-400">Card Type</label>
                            <select id="cardType" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                                <option>Creature</option>
                                <option>Planeswalker</option>
                                <option>Sorcery</option>
                                <option>Instant</option>
                                <option>Enchantment</option>
                                <option>Artifact</option>
                                <option>Land</option>
                            </select>
                        </div>
                        <div>
                            <label for="cardSubtype" class="block text-sm font-medium text-gray-400">Card Subtype (e.g. Human Soldier)</label>
                            <input type="text" id="cardSubtype" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                         <div class="col-span-1 md:col-span-2">
                            <label for="manaCost" class="block text-sm font-medium text-gray-400">Mana Cost (e.g., {2}{W}{U})</label>
                            <input type="text" id="manaCost" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                        <div class="col-span-1 md:col-span-2">
                            <label for="cardText" class="block text-sm font-medium text-gray-400">Text Box</label>
                            <textarea id="cardText" rows="3" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                        </div>
                        <div class="col-span-1 md:col-span-2">
                            <label for="cardFlavourText" class="block text-sm font-medium text-gray-400">Flavour Text</label>
                            <textarea id="cardFlavourText" rows="2" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                        </div>
                        <div id="creatureFields" class="hidden col-span-1 md:col-span-2 grid grid-cols-2 gap-4">
                            <div>
                                <label for="power" class="block text-sm font-medium text-gray-400">Power</label>
                                <input type="number" id="power" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                            </div>
                            <div>
                                <label for="toughness" class="block text-sm font-medium text-gray-400">Toughness</label>
                                <input type="number" id="toughness" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                            </div>
                        </div>
                        <div id="planeswalkerFields" class="hidden col-span-1">
                            <label for="loyalty" class="block text-sm font-medium text-gray-400">Starting Loyalty</label>
                            <input type="number" id="loyalty" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                    </div>
                </form>
                <div id="message-area" class="hidden my-4 p-3 rounded-lg"></div>
                <div class="mt-4 flex gap-4">
                    <button id="saveCardBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform transform hover:scale-105">Add to Collection</button>
                    <button id="cancelEditBtn" class="hidden w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Cancel Edit</button>
                </div>
            </div>
        </div>
        <!-- Bulk Import (CSV) Tab -->
        <div id="tab-content-import" class="tab-content">
            <div class="bg-gray-900 p-6 rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold mb-4">Bulk Import Cards via CSV</h2>
                <div class="space-y-6">
                    <div>
                        <h3 class="text-lg font-medium text-indigo-400">Instructions</h3>
                        <ul class="list-disc list-inside text-gray-400 text-sm mt-2 space-y-1">
                            <li>**Mandatory Columns:** `Card Name`, `Card Type`</li>
                            <li>If `Card Type` is "Creature", `Power` and `Toughness` are also mandatory.</li>
                            <li>**Optional Columns:** `Card Subtype`, `Mana Cost`, `Text Box`, `Flavour Text`, `Image Filename`, `Commander?` (Y)</li>
                            <li>If `Image Filename` is blank, a placeholder will be used.</li>
                        </ul>
                    </div>
                    <div>
                        <h3 class="text-lg font-medium text-indigo-400">Step 1: Upload Images (.zip file)</h3>
                        <p class="text-gray-400 text-sm mt-1">Select a single .zip file containing all the image files referenced in your CSV.</p>
                        <input type="file" id="bulkImageUpload" accept=".zip" class="mt-2 block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-700">
                        <div id="image-upload-progress" class="mt-2 text-sm text-gray-400"></div>
                    </div>
                    <div>
                        <h3 class="text-lg font-medium text-indigo-400">Step 2: Upload CSV File</h3>
                        <p class="text-gray-400 text-sm mt-1">CSV must have a header row with the column names listed above.</p>
                        <input type="file" id="csvFile" accept=".csv" class="mt-2 block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-700">
                    </div>
                    <div id="import-message-area" class="hidden my-4 p-3 rounded-lg"></div>
                    <div class="flex flex-col sm:flex-row gap-4">
                        <button id="importCsvBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Import to Collection</button>
                        <button id="importAndAddBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Import & Add to Deck</button>
                    </div>
                    </div>
            </div>
        </div>
        <!-- Scryfall Import Tab -->
        <div id="tab-content-scryfall" class="tab-content">
            <div class="bg-gray-900 p-6 rounded-lg shadow-lg">
                <h1 class="text-2xl font-bold mb-2 text-indigo-400">Scryfall Bulk Importer</h1>
                <p class="text-gray-400 mb-6">Paste a list of card names, one per line, to fetch their data from the Scryfall API.</p>
                <!-- Input Section -->
                <div class="mb-4">
                    <label for="cardListInput" class="block text-lg font-medium text-gray-300">Card Names</label>
                    <textarea id="cardListInput" rows="10" class="mt-2 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="Sol Ring&#10;Swords to Plowshares&#10;Rhystic Study&#10;..."></textarea>
                </div>
                <button id="fetchBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg text-lg transition-transform transform hover:scale-105 shadow-md">
                    Fetch Card Data
                </button>
                <!-- Progress and Status Section -->
                <div id="statusArea" class="mt-4 text-center"></div>
                <!-- Results Section -->
                <div id="resultsArea" class="mt-6 hidden">
                    <h2 class="text-xl font-semibold mb-4 text-green-400">Results</h2>
                    <div id="foundCardsSection">
                        <h3 class="text-lg font-medium text-gray-300">Found Cards (<span id="foundCount">0</span>)</h3>
                        <div id="foundCardsGrid" class="mt-4 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                            <!-- Card previews will be injected here -->
                        </div>
                    </div>
                    <div id="notFoundSection" class="mt-6">
                        <h3 class="text-lg font-medium text-red-400">Not Found (<span id="notFoundCount">0</span>)</h3>
                        <ul id="notFoundList" class="mt-2 list-disc list-inside text-gray-400 text-sm">
                            <!-- Not found card names will be injected here -->
                        </ul>
                    </div>
                    <div class="mt-6 border-t border-gray-700 pt-6">
                         <h3 class="text-lg font-medium text-gray-300">Save to Collection or Export</h3>
                         <p class="text-gray-400 text-sm mb-4">You can add these cards directly to your collection or download a CSV file.</p>
                         <div class="flex flex-col sm:flex-row gap-4">
                            <button id="addDirectlyBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md" disabled>
                                Add to My Collection
                            </button>
                            <button id="downloadCsvBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md" disabled>
                                Download as CSV
                           </button>
                         </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="mt-8 grid grid-cols-1 lg:grid-cols-3 gap-8">
        <div class="lg:col-span-2">
            
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold">My Card Collection</h2>
                <div id="view-toggle-buttons" class="flex items-center gap-2">
                    <button id="grid-view-btn" class="p-2 rounded-md bg-indigo-600 text-white">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5zM11 5a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V5zM11 13a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
                        </svg>
                    </button>
                    <button id="list-view-btn" class="p-2 rounded-md bg-gray-700 text-gray-400 hover:bg-gray-600 hover:text-white">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </div>
            </div>
            
            <!-- Filter and Sort Controls -->
            <div class="bg-gray-900 p-4 rounded-lg mb-4 flex flex-wrap gap-4 items-center">
                <input type="text" id="filterName" placeholder="Filter by name..." class="flex-grow bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 min-w-[200px]">
                <select id="filterType" class="bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    <option value="">All Types</option>
                    <option>Creature</option>
                    <option>Planeswalker</option>
                    <option>Sorcery</option>
                    <option>Instant</option>
                    <option>Enchantment</option>
                    <option>Artifact</option>
                    <option>Land</option>
                </select>
                <select id="filterColor" class="bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    <option value="">All Colors</option>
                    <option value="W">White</option>
                    <option value="U">Blue</option>
                    <option value="B">Black</option>
                    <option value="R">Red</option>
                    <option value="G">Green</option>
                    <option value="C">Colorless</option>
                    <option value="M">Multi-Color</option>
                </select>
                <div class="flex items-center bg-gray-700 border border-gray-600 rounded-md shadow-sm">
                    <select id="manaValueOperator" class="bg-gray-700 rounded-l-md py-2 pl-3 pr-1 border-r border-gray-600 text-white focus:outline-none">
                        <option value="=">=</option>
                        <option value="<"><</option>
                        <option value="<="><=</option>
                        <option value=">">></option>
                        <option value=">=">>=</option>
                    </select>
                    <input type="number" id="manaValueFilter" placeholder="MV" class="w-16 bg-gray-700 py-2 px-2 text-white focus:outline-none rounded-r-md">
                </div>
                <select id="filterSource" class="bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    <option value="">All Sources</option>
                    <option value="custom">User-Created</option>
                    <option value="scryfall">Scryfall</option>
                </select>
                <select id="filterSort" class="bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    <option value="name_asc">Sort: Name (A-Z)</option>
                    <option value="name_desc">Sort: Name (Z-A)</option>
                    <option value="mv_asc">Sort: Mana Value (Low-High)</option>
                    <option value="mv_desc">Sort: Mana Value (High-Low)</option>
                </select>
                <div class="flex-grow"></div> <!-- This is a spacer to push the new button to the right -->
                <button id="toggle-select-mode-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">
                    Select
                </button>
            </div>

            <div id="selection-action-bar" class="hidden bg-gray-900 p-3 rounded-lg mb-4 flex justify-between items-center">
                <span id="selection-count" class="text-gray-400">0 cards selected</span>
                <div class="flex gap-4">
                    <button id="select-all-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Select All on Page</button>
                    <button id="deselect-all-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Deselect All</button>
                    <button id="add-selected-to-deck-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Add to Deck</button>
                    <button id="delete-selected-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Delete Selected</button>
                </div>
            </div>

            <div id="cardCollection" class="bg-gray-900 p-4 rounded-lg min-h-[300px] grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4"></div>
            <div id="pagination-controls" class="flex justify-between items-center mt-4 flex-wrap gap-4">
                <button id="prev-page-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg disabled:bg-gray-600 disabled:cursor-not-allowed">
                    &larr; Previous
                </button>

                <div class="flex items-center gap-4">
                    <span id="page-info" class="text-gray-400 text-sm">Page 1 of 1</span>
                    <div class="flex items-center gap-2">
                        <label for="jump-to-page-input" class="text-sm text-gray-400">Jump to:</label>
                        <input type="number" id="jump-to-page-input" class="w-16 bg-gray-700 border border-gray-600 rounded-md py-1 px-2 text-white">
                    </div>
                </div>

                <div class="flex items-center gap-2">
                    <label for="cards-per-page-select" class="text-sm text-gray-400">Show:</label>
                    <select id="cards-per-page-select" class="bg-gray-700 border border-gray-600 rounded-md py-1 px-2 text-white">
                        <option value="20">20</option>
                        <option value="50">50</option>
                        <option value="100">100</option>
                    </select>
                </div>

                <button id="next-page-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg disabled:bg-gray-600 disabled:cursor-not-allowed">
                    Next &rarr;
                </button>
            </div>
        </div>
        <div>
            <div class="bg-gray-900 p-4 rounded-lg mb-8">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-semibold">Assemble Deck</h2>
                    <button id="clearDeckBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-lg text-sm">Clear</button>
                </div>
                <div class="flex items-center mb-4">
                    <input type="text" id="deckName" placeholder="Deck Name" class="block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    <button id="saveDeck" class="ml-2 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Save</button>
                </div>
                <div class="mb-2">
                    <h3 class="text-lg font-semibold text-indigo-400">Commander(s)</h3>
                    <div id="commanderList" class="min-h-[30px] bg-gray-800 p-2 rounded-md text-sm">
                        <p class="text-gray-500">Right-click a card in the deck below to set as commander.</p>
                    </div>
                </div>
                <div class="flex justify-between items-center">
                    <h3 class="text-lg font-semibold text-gray-300">Main Deck (<span id="deckCount">0</span>)</h3>
                    <select id="sortDeckSelect" class="bg-gray-700 border border-gray-600 rounded-md shadow-sm py-1 px-2 text-white text-xs focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="name">Sort by Name</option>
                        <option value="type">Sort by Type</option>
                        <option value="mv">Sort by MV</option>
                    </select>
                </div>
                <div id="deckList" class="min-h-[200px] bg-gray-800 p-2 rounded-md"></div>
            </div>
            <div class="bg-gray-900 p-4 rounded-lg">
                <h2 class="text-2xl font-semibold mb-4">Saved Decks</h2>
                <div id="savedDecks" class="space-y-2"></div>
            </div>
        </div>
    </div>
    
    <div id="lobby-section" class="mt-8 bg-gray-900 p-6 rounded-lg shadow-lg">
        <h2 class="text-2xl font-semibold mb-4 text-green-400">Game Lobby</h2>
        
        <div id="lobby-controls">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="playerName" class="block text-sm font-medium text-gray-400">Your Name</label>
                    <input type="text" id="playerName" placeholder="Enter your name..." class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div>
                    <label for="gameMode" class="block text-sm font-medium text-gray-400">Game Mode</label>
                    <select id="gameMode" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="40">EDH / Commander (40 Life)</option>
                        <option value="20">Standard / Modern (20 Life)</option>
                    </select>
                </div>
            </div>

            <p class="text-gray-400 mb-4">Assemble or load a deck, then start or join a game.</p>
            
            <div class="space-y-4">
                <button id="createGameBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg text-lg">Create New Game</button>
                <div class="relative">
                    <div class="absolute inset-0 flex items-center" aria-hidden="true"><div class="w-full border-t border-gray-700"></div></div>
                    <div class="relative flex justify-center"><span class="bg-gray-900 px-2 text-sm text-gray-500">OR</span></div>
                </div>
                <div class="flex gap-4">
                    <input type="text" id="joinGameIdInput" placeholder="Enter Game ID..." class="block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 text-white focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    <button id="joinGameBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Join Game</button>
                </div>
            </div>
        </div>

        <div id="game-created-section" class="hidden text-center">
            <h3 class="text-xl font-semibold text-green-400">Game Created!</h3>
            <p class="text-gray-400 mt-2">Share this link with your friends to invite them:</p>
            <div class="mt-4 flex items-center bg-gray-800 p-2 rounded-lg">
                <input type="text" id="inviteLinkInput" readonly class="w-full bg-transparent text-gray-300 focus:outline-none">
                <button id="copyLinkBtn" class="ml-4 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Copy</button>
            </div>
            <button id="enterGameBtn" class="mt-6 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg text-lg">Enter Game</button>
        </div>

    </div>

    <!-- updated: Pop-out element for card previews -->
    <div id="card-popout" class="rounded-lg shadow-2xl p-2 space-y-2">
        <div class="flex justify-between items-start">
            <span id="popout-name" class="font-bold"></span>
            <span id="popout-cost" class="text-sm flex gap-1 items-center"></span>
        </div>
        <img id="popout-img" src="" alt="Card Image" class="rounded-md">
        <div class="flex justify-between items-center text-sm">
            <span id="popout-type" class="font-semibold"></span>
            <span id="popout-pt" class="font-bold"></span>
        </div>
        <div id="popout-text" class="text-xs bg-gray-800 p-2 rounded-md whitespace-pre-wrap max-h-40 overflow-y-auto"></div>
        <div id="popout-flavour" class="text-xs text-gray-400 italic"></div>
    </div>

    <!-- NEW: Pop-out element for detailed card previews -->
    <div id="card-popout" class="rounded-lg shadow-2xl p-2 space-y-2">
        <div class="flex justify-between items-start">
            <span id="popout-name" class="font-bold"></span>
            <span id="popout-cost" class="text-sm flex gap-1 items-center"></span>
        </div>
        <img id="popout-img" src="" alt="Card Image" class="rounded-md">
        <div class="flex justify-between items-center text-sm">
            <span id="popout-type" class="font-semibold"></span>
            <span id="popout-pt" class="font-bold"></span>
        </div>
        <div id="popout-text" class="text-xs bg-gray-800 p-2 rounded-md whitespace-pre-wrap max-h-40 overflow-y-auto"></div>
        <div id="popout-flavour" class="text-xs text-gray-400 italic"></div>
    </div>

    <div id="import-review-modal" class="hidden fixed inset-0 bg-black/80 z-50 flex flex-col p-4">
        <div class="bg-gray-800 rounded-lg max-w-7xl w-full max-h-full mx-auto flex flex-col p-6 shadow-2xl border border-indigo-500">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 class="text-2xl font-bold text-indigo-300">Review Scryfall Import</h2>
                <button id="import-review-close" class="text-3xl font-light text-gray-400 hover:text-white leading-none">&times;</button>
            </div>
            <div class="mb-4 flex-shrink-0 flex justify-between items-center">
                <span id="import-selection-count" class="text-gray-400">0 cards selected</span>
                <div>
                    <button id="import-select-all-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg mr-2">Select All</button>
                    <button id="import-deselect-all-btn" class="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">Deselect All</button>
                </div>
            </div>
            <div id="import-review-content" class="card-container flex-grow overflow-y-auto justify-center border-t border-b border-gray-700 py-4">
                <!-- Fetched cards will be displayed here for selection -->
            </div>
            <div class="mt-4 flex-shrink-0 flex justify-end gap-4">
                <button id="import-review-cancel" class="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">Cancel</button>
                <button id="import-review-add-to-deck" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Add to Deck</button>
                <button id="import-review-confirm" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg">Add Selected to Collection</button>
            </div>
        </div>
    </div>
    <div id="add-to-deck-modal" class="hidden fixed inset-0 bg-black/80 z-[60] flex items-center justify-center p-4">
    <div class="bg-gray-800 rounded-lg max-w-md w-full p-6 shadow-2xl border border-indigo-500">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-2xl font-bold text-indigo-300">Add to Deck(s)</h2>
            <button id="add-to-deck-close-btn" class="text-3xl font-light text-gray-400 hover:text-white leading-none">&times;</button>
        </div>
        <p class="text-gray-400 mb-4">Choose one or more destination decks for the selected cards.</p>
        <div id="deck-choice-list" class="space-y-3 max-h-64 overflow-y-auto border-t border-b border-gray-700 py-3">
            <!-- Deck checkboxes will be dynamically inserted here -->
        </div>
        <div class="mt-4 flex justify-end">
            <button id="add-to-deck-confirm-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Confirm</button>
        </div>
    </div>
</div>

<!-- Modal for Import Summaries -->
<div id="import-summary-modal" class="hidden fixed inset-0 bg-black/80 z-[70] flex items-center justify-center p-4">
    <div class="bg-gray-800 rounded-lg max-w-md w-full p-6 shadow-2xl border border-indigo-500 flex flex-col max-h-[80vh]">
        <div class="flex justify-between items-center mb-4 flex-shrink-0">
            <h2 id="import-summary-title" class="text-2xl font-bold text-indigo-300">Import Summary</h2>
            <button id="import-summary-close-btn" class="text-3xl font-light text-gray-400 hover:text-white leading-none">&times;</button>
        </div>
        <ul id="import-summary-list" class="space-y-1 text-sm text-gray-300 overflow-y-auto">
            <!-- Card names will be dynamically inserted here -->
        </ul>
    </div>
</div>

    <script>
    // --- DOM Elements (Declared Globally) ---
    let cardCollectionEl, deckListEl, commanderListEl, deckCountEl, deckNameEl, saveDeckBtn, clearDeckBtn, sortDeckSelect, savedDecksEl,
        saveCardBtn, cancelEditBtn, formTitleEl, cardTypeSelect, creatureFields, planeswalkerFields,
        createGameBtn, joinGameBtn, joinGameIdInput, messageAreaEl, importCsvBtn, imageUploadProgressEl,
        lobbySectionEl, lobbyControlsEl, gameCreatedSectionEl, inviteLinkInputEl, copyLinkBtn, enterGameBtn,
        cardListInput, fetchBtn, statusArea, resultsArea, foundCardsGrid, notFoundList, foundCount,
        notFoundCount, downloadCsvBtn, addDirectlyBtn, importReviewModal, importReviewClose,
        importSelectAllBtn, importDeselectAllBtn, importSelectionCountEl, importReviewContent,
        importReviewCancel, importReviewConfirm, filterNameInput, filterTypeSelect, filterSortSelect,
        filterColorSelect, filterSourceSelect, prevPageBtn, nextPageBtn, pageInfoEl, toggleSelectModeBtn,
        selectionActionBar, selectionCountEl, deleteSelectedBtn, addSelectedToDeckBtn, selectAllBtn, deselectAllBtn, cardPopoutEl,
        popoutNameEl, popoutCostEl, popoutImgEl, popoutTypeEl, popoutPtEl, popoutTextEl, popoutFlavourEl, 
        importReviewAddToDeckBtn, addToDeckModal, addToDeckCloseBtn, deckChoiceList, addToDeckConfirmBtn,
        gridViewBtn, listViewBtn, manaValueOperator, manaValueFilter;

    // --- Global State ---
        let allCards = [];
        let currentDeck = [];
        let commanders = [];
        let uploadedImageMap = new Map();
        let myUserId = null;
        let editingCardId = null; 
        let csvFileToProcess = null;
        let importAndAddBtn = null;
        let fetchedCardsData = []; // To store the processed card data for CSV/direct export
        let isSelectMode = false;
        let selectedCards = new Set();
        let importSelectedCards = new Set();
        let deckSortOrder = 'name'; 
        let currentPage = 1;
        let cardsPerPage = 20; // You can change this number to show more or fewer cards (potentially - this note was originally written when this was a const)
        let currentView = 'grid'; // Can be 'grid' or 'list'
        let currentlyVisibleCards = [];
        let jumpToPageInput, cardsPerPageSelect;

        // --- MESSAGE FUNCTIONS ---
        const showMessage = (message, isError = true, area = 'create') => {
            const areaMap = {
                create: document.getElementById('message-area'),
                import: document.getElementById('import-message-area'),
                scryfall: document.getElementById('statusArea')
            };
            const targetArea = areaMap[area];
            if (!targetArea) return; 

            targetArea.innerHTML = `<p>${message}</p>`; // Use innerHTML to render as a paragraph
            targetArea.classList.remove('hidden');
            if (isError) {
                targetArea.firstChild.className = 'text-red-400';
            } else {
                targetArea.firstChild.className = 'text-green-400';
            }
        };
        const hideMessage = (area = 'create') => {
            const areaMap = {
                create: document.getElementById('message-area'),
                import: document.getElementById('import-message-area'),
                scryfall: document.getElementById('statusArea')
            };
            const targetArea = areaMap[area];
            if(targetArea) targetArea.classList.add('hidden');
        };

        //Toggle Select Mode
        const toggleSelectMode = () => {
            isSelectMode = !isSelectMode; // Flip the mode on/off
            selectedCards.clear(); // Clear any previous selections

            if (isSelectMode) {
                toggleSelectModeBtn.textContent = 'Cancel';
                toggleSelectModeBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                toggleSelectModeBtn.classList.add('bg-gray-600', 'hover:bg-gray-700');
                selectionActionBar.classList.remove('hidden');
            } else {
                toggleSelectModeBtn.textContent = 'Select';
                toggleSelectModeBtn.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                toggleSelectModeBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                selectionActionBar.classList.add('hidden');
            }
            renderFilteredCollection(); // Re-render the collection to update card styles
        };

        const handleSelectAllOnPage = () => {
            // Use the data array directly instead of querying the DOM
            currentlyVisibleCards.forEach(card => {
                selectedCards.add(card.id);
            });
            selectionCountEl.textContent = `${selectedCards.size} cards selected`;
            renderFilteredCollection(); // Re-render to show the new selections
        };

        // Flexibility with cards per page and jumping to specific pages with cards
        const handleJumpToPage = (event) => {
            const page = parseInt(event.target.value, 10);
            const totalPages = Math.ceil(allCards.length / cardsPerPage);
            if (page >= 1 && page <= totalPages) {
                currentPage = page;
                renderFilteredCollection();
            }
            event.target.value = ''; // Clear the input after jumping
        };

        const handlePerPageChange = (event) => {
            cardsPerPage = parseInt(event.target.value, 10);
            currentPage = 1; // Reset to the first page
            renderFilteredCollection();
        };

        const handleDeselectAll = () => {
            selectedCards.clear();
            selectionCountEl.textContent = `0 cards selected`;
            renderFilteredCollection(); // Re-render to remove all selection highlights
        };

        // --- RENDER FUNCTIONS ---
        // NEW (Corrected): This function parses a mana cost string and returns HTML for the symbols.
        const parseManaCost = (cost, symbolClass = '') => {
            if (!cost) return '';
            
            const symbolRegex = /\{(.+?)\}/g;
            // This replaces each {symbol} with a direct link to Scryfall's high-quality SVG image for that symbol.
            return cost.replace(symbolRegex, (match, symbol) => {
                const sanitizedSymbol = symbol.replace('/', ''); // Handles symbols like {W/P}
                return `<img src="https://svgs.scryfall.io/card-symbols/${sanitizedSymbol.toUpperCase()}.svg" alt="${symbol}" class="${symbolClass}" style="width: 16px; height: 16px; vertical-align: middle;">`;
            });
        };

    // NEW: Functions to control the card pop-out
        function showCardPopout(event, cardData) {
            if (cardData) {
                // Populate the popout elements with data
                popoutNameEl.textContent = cardData.name;
                popoutCostEl.innerHTML = parseManaCost(cardData.cost, 'mana-symbol-cost');
                popoutImgEl.src = cardData.imageUrl || 'https://placehold.co/280x200/2d3748/e2e8f0?text=No+Image';
                
                let typeLine = cardData.type || '';
                if (cardData.subtype) {
                    typeLine += ` â€” ${cardData.subtype}`;
                }
                popoutTypeEl.textContent = typeLine;
                
                popoutTextEl.innerHTML = (cardData.text || '').replace(/\n/g, '<br>');
                
                if (cardData.flavourText) {
                    popoutFlavourEl.innerHTML = (cardData.flavourText || '').replace(/\n/g, '<br>');
                    popoutFlavourEl.style.display = 'block';
                } else {
                    popoutFlavourEl.style.display = 'none';
                }
                
                if (cardData.power && cardData.toughness) {
                    popoutPtEl.textContent = `${cardData.power}/${cardData.toughness}`;
                } else if (cardData.loyalty) {
                    popoutPtEl.textContent = `Loyalty: ${cardData.loyalty}`;
                } else {
                    popoutPtEl.textContent = '';
                }

                cardPopoutEl.style.display = 'block';
            }
        }

        function hideCardPopout() {
            cardPopoutEl.style.display = 'none';
        }

        function moveCardPopout(event) {
            const popoutHeight = cardPopoutEl.offsetHeight;
            const popoutWidth = cardPopoutEl.offsetWidth;
            const buffer = 20;

            let top = event.clientY + buffer;
            let left = event.clientX + buffer;

            // Logic to keep the popout on the screen
            if (top + popoutHeight > window.innerHeight) {
                top = event.clientY - popoutHeight - buffer;
            }
            if (top < 0) {
                top = buffer;
            }
            if (left + popoutWidth > window.innerWidth) {
                left = event.clientX - popoutWidth - buffer;
            }

            cardPopoutEl.style.left = `${left}px`;
            cardPopoutEl.style.top = `${top}px`;
        }
        const renderCard = (card, container) => {
            const cardWrapper = document.createElement('div');
            // ADDED border-2 and border-transparent to prevent layout shift
            cardWrapper.className = 'p-2 bg-gray-700 rounded-lg flex flex-col items-center justify-between transition-all border-2 border-transparent';

            // --- UPDATED: Add a highlight if the card is selected ---
            if (selectedCards.has(card.id)) {
                cardWrapper.classList.remove('border-transparent');
                cardWrapper.classList.add('border-blue-500'); // Use border instead of ring
            }

            const clickableArea = document.createElement('div');
            clickableArea.className = 'cursor-pointer text-center';

            clickableArea.addEventListener('click', () => {
                if (isSelectMode) {
                    if (selectedCards.has(card.id)) {
                        selectedCards.delete(card.id);
                        cardWrapper.classList.add('border-transparent');
                        cardWrapper.classList.remove('border-blue-500'); // Use border instead of ring
                    } else {
                        selectedCards.add(card.id);
                        cardWrapper.classList.remove('border-transparent');
                        cardWrapper.classList.add('border-blue-500'); // Use border instead of ring
                    }
                    selectionCountEl.textContent = `${selectedCards.size} cards selected`;
                } else {
                    addCardToDeck(card);
                }
            });

            const img = document.createElement('img');
            img.src = card.imageUrl || 'https://placehold.co/100x140/2d3748/e2e8f0?text=No+Image';
            img.alt = card.name;
            img.className = 'card-image-sm object-cover rounded-md mb-2';

            const name = document.createElement('span');
            name.textContent = card.name;
            name.className = 'text-xs text-center font-semibold';

            clickableArea.appendChild(img);
            clickableArea.appendChild(name);

            const infoDiv = document.createElement('div');
            infoDiv.className = 'text-center my-2 w-full';

            const typeText = document.createElement('p');
            typeText.textContent = card.type;
            typeText.className = 'text-xs text-gray-400 truncate';
            infoDiv.appendChild(typeText);

            const colorPips = document.createElement('div');
            colorPips.className = 'flex justify-center items-center mt-1 h-4';
            colorPips.innerHTML = parseManaCost(card.cost, 'mana-symbol');
            infoDiv.appendChild(colorPips);

            const buttonBar = document.createElement('div');
            buttonBar.className = 'flex justify-around w-full mt-2';

            const editBtn = document.createElement('button');
            editBtn.textContent = 'Edit';
            editBtn.className = 'text-xs bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded';
            editBtn.onclick = () => populateFormForEdit(card.id);

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'Delete';
            deleteBtn.className = 'text-xs bg-red-600 hover:bg-red-700 px-2 py-1 rounded';
            deleteBtn.onclick = () => deleteCard(card.id);

            buttonBar.appendChild(editBtn);
            buttonBar.appendChild(deleteBtn);

            cardWrapper.appendChild(clickableArea);
            cardWrapper.appendChild(infoDiv);
            cardWrapper.appendChild(buttonBar);

            cardWrapper.addEventListener('mouseenter', (e) => showCardPopout(e, card));
            cardWrapper.addEventListener('mouseleave', hideCardPopout);
            cardWrapper.addEventListener('mousemove', moveCardPopout);
            container.appendChild(cardWrapper);
        };

        const renderCardAsListItem = (card, container) => {
            const listItem = document.createElement('div');
            listItem.dataset.cardId = card.id;
            listItem.className = 'p-2 bg-gray-700 rounded-lg flex items-center gap-4 transition-all border-2 border-transparent';

            // --- Add a highlight if the card is selected ---
            if (selectedCards.has(card.id)) {
                listItem.classList.replace('border-transparent', 'border-blue-500');
            }

            // Clickable area for selection/adding to deck
            listItem.addEventListener('click', () => {
                if (isSelectMode) {
                    if (selectedCards.has(card.id)) {
                        selectedCards.delete(card.id);
                        listItem.classList.replace('border-blue-500', 'border-transparent');
                    } else {
                        selectedCards.add(card.id);
                        listItem.classList.replace('border-transparent', 'border-blue-500');
                    }
                    selectionCountEl.textContent = `${selectedCards.size} cards selected`;
                } else {
                    addCardToDeck(card);
                }
            });

            const name = document.createElement('span');
            name.textContent = card.name;
            name.className = 'flex-grow font-semibold text-white truncate';

            const type = document.createElement('span');
            type.textContent = card.type;
            type.className = 'w-32 flex-shrink-0 text-gray-400 text-sm truncate';

            const cost = document.createElement('div');
            cost.className = 'w-24 flex-shrink-0 flex justify-end';
            cost.innerHTML = parseManaCost(card.cost, 'mana-symbol');

            const buttonBar = document.createElement('div');
            buttonBar.className = 'flex gap-2';

            const editBtn = document.createElement('button');
            editBtn.textContent = 'Edit';
            editBtn.className = 'text-xs bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded';
            editBtn.onclick = (e) => { e.stopPropagation(); populateFormForEdit(card.id); };

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'Delete';
            deleteBtn.className = 'text-xs bg-red-600 hover:bg-red-700 px-2 py-1 rounded';
            deleteBtn.onclick = (e) => { e.stopPropagation(); deleteCard(card.id); };

            buttonBar.appendChild(editBtn);
            buttonBar.appendChild(deleteBtn);

            listItem.appendChild(name);
            listItem.appendChild(type);
            listItem.appendChild(cost);
            listItem.appendChild(buttonBar);

            container.appendChild(listItem);
        };

        /**
         * Helper function to determine a card's color identity from its mana cost.
         */
        const getCardColorIdentity = (manaCost) => {
            if (!manaCost) return ['C']; // Colorless if no cost
            const colors = new Set();
            if (manaCost.includes('W')) colors.add('W');
            if (manaCost.includes('U')) colors.add('U');
            if (manaCost.includes('B')) colors.add('B');
            if (manaCost.includes('R')) colors.add('R');
            if (manaCost.includes('G')) colors.add('G');
            
            if (colors.size === 0) return ['C']; // Also colorless (e.g., artifacts, lands)
            if (colors.size > 1) return ['M', ...Array.from(colors)]; // Return M for multi-color, plus individual colors
            return Array.from(colors);
        };

        const getManaValue = (manaCost) => {
            if (!manaCost) return 0;
            let mv = 0;
            const symbolRegex = /\{(.+?)\}/g;
            let match;
            while ((match = symbolRegex.exec(manaCost)) !== null) {
                const symbol = match[1];
                const numericValue = parseInt(symbol, 10);
                if (!isNaN(numericValue)) {
                    mv += numericValue; // Adds numbers like {2}, {16}, etc.
                } else if (symbol.includes('/')) {
                    mv += 1; // Hybrid and Phyrexian mana count as 1.
                } else if (symbol !== 'X' && symbol !== 'Y' && symbol !== 'Z') {
                    mv += 1; // Regular colored pips count as 1.
                }
            }
            return mv;
        };

        const renderFilteredCollection = () => {
            let filteredCards = [...allCards];

            // --- Add Mana Value to each card for sorting/filtering ---
            filteredCards.forEach(card => {
                card.mv = getManaValue(card.cost);
            });

            // --- Filtering Logic ---
            const nameQuery = filterNameInput.value.toLowerCase();
            if (nameQuery) filteredCards = filteredCards.filter(card => card.name.toLowerCase().includes(nameQuery));

            const typeQuery = filterTypeSelect.value;
            if (typeQuery) filteredCards = filteredCards.filter(card => card.type === typeQuery);

            const colorQuery = filterColorSelect.value;
            if (colorQuery) filteredCards = filteredCards.filter(card => getCardColorIdentity(card.cost).includes(colorQuery));

            const sourceQuery = filterSourceSelect.value;
            if (sourceQuery) filteredCards = filteredCards.filter(card => card.source === sourceQuery);

            // --- NEW Mana Value Filter Logic ---
            const mvValue = parseInt(manaValueFilter.value, 10);
            if (!isNaN(mvValue)) {
                const operator = manaValueOperator.value;
                filteredCards = filteredCards.filter(card => {
                    if (operator === '=') return card.mv === mvValue;
                    if (operator === '<') return card.mv < mvValue;
                    if (operator === '<=') return card.mv <= mvValue;
                    if (operator === '>') return card.mv > mvValue;
                    if (operator === '>=') return card.mv >= mvValue;
                    return true;
                });
            }

            // --- Sorting Logic ---
            const sortQuery = filterSortSelect.value;
            if (sortQuery === 'name_asc') {
                filteredCards.sort((a, b) => a.name.localeCompare(b.name));
            } else if (sortQuery === 'name_desc') {
                filteredCards.sort((a, b) => b.name.localeCompare(a.name));
            } else if (sortQuery === 'mv_asc') {
                filteredCards.sort((a, b) => a.mv - b.mv || a.name.localeCompare(b.name));
            } else if (sortQuery === 'mv_desc') {
                filteredCards.sort((a, b) => b.mv - a.mv || a.name.localeCompare(b.name));
            }

            // --- Pagination and Rendering ---
            cardsPerPage = parseInt(cardsPerPageSelect.value, 10);
            const totalPages = Math.ceil(filteredCards.length / cardsPerPage);
            if (currentPage > totalPages && totalPages > 0) currentPage = totalPages;
            const startIndex = (currentPage - 1) * cardsPerPage;
            const endIndex = startIndex + cardsPerPage;
            const paginatedCards = filteredCards.slice(startIndex, endIndex);
            currentlyVisibleCards = paginatedCards;
            cardCollectionEl.innerHTML = '';
            if (currentView === 'grid') {
                cardCollectionEl.className = 'bg-gray-900 p-4 rounded-lg min-h-[300px] grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4';
                paginatedCards.forEach(card => renderCard(card, cardCollectionEl));
            } else {
                cardCollectionEl.className = 'bg-gray-900 p-4 rounded-lg min-h-[300px] flex flex-col gap-2';
                paginatedCards.forEach(card => renderCardAsListItem(card, cardCollectionEl));
            }
            pageInfoEl.textContent = `Page ${currentPage} of ${totalPages || 1}`;
            prevPageBtn.disabled = currentPage === 1;
            nextPageBtn.disabled = currentPage === totalPages || totalPages === 0;
        };

        const renderCollection = () => {
            renderFilteredCollection();
        };
        
        const renderDeckList = () => {
            deckListEl.innerHTML = '';
            const mainDeck = currentDeck.filter(card => !commanders.some(c => c.id === card.id));
            deckCountEl.textContent = mainDeck.length;

            const cardCounts = mainDeck.reduce((acc, card) => {
                acc[card.id] = (acc[card.id] || 0) + 1;
                return acc;
            }, {});

            // Create an array of unique card objects that includes their count
            let uniqueCards = Object.keys(cardCounts).map(cardId => {
                const card = allCards.find(c => c.id === cardId);
                // Ensure the mana value is calculated for sorting
                if (card && card.mv === undefined) {
                    card.mv = getManaValue(card.cost);
                }
                return { ...card, count: cardCounts[cardId] };
            });

            // Now, sort the array of unique cards
            if (deckSortOrder === 'name') {
                uniqueCards.sort((a, b) => a.name.localeCompare(b.name));
            } else if (deckSortOrder === 'type') {
                uniqueCards.sort((a, b) => a.type.localeCompare(b.type) || a.name.localeCompare(b.name));
            } else if (deckSortOrder === 'mv') {
                uniqueCards.sort((a, b) => a.mv - b.mv || a.name.localeCompare(b.name));
            }

            // Finally, iterate over the *sorted* array to render the list
            uniqueCards.forEach(card => {
                if (card && card.id) { // Check for card.id to filter out any potential bad data
                    const deckItem = document.createElement('div');
                    deckItem.className = 'deck-item text-sm p-1 flex justify-between items-center';
                    deckItem.textContent = `${card.count}x ${card.name}`;

                    deckItem.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        setCommander(card);
                    });

                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = 'x';
                    removeBtn.className = 'ml-2 text-red-400 hover:text-red-200';
                    removeBtn.onclick = () => removeCardFromDeck(card.id);
                    deckItem.appendChild(removeBtn);
                    deckListEl.appendChild(deckItem);
                }
            });

            renderCommanders();
        };

        const renderCommanders = () => {
            commanderListEl.innerHTML = '';
            if (commanders.length === 0) {
                commanderListEl.innerHTML = '<p class="text-gray-500">Right-click a card in the deck below to set as commander.</p>';
            } else {
                commanders.forEach(card => {
                    const commanderItem = document.createElement('div');
                    commanderItem.className = 'deck-item commander p-1 flex justify-between items-center';
                    commanderItem.textContent = `â­ ${card.name}`;
                    
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = 'x';
                    removeBtn.className = 'ml-2 text-red-400 hover:text-red-200';
                    removeBtn.onclick = () => unsetCommander(card.id);
                    commanderItem.appendChild(removeBtn);
                    commanderListEl.appendChild(commanderItem);
                });
            }
        };
        
        const renderSavedDecks = async () => {
            savedDecksEl.innerHTML = '';
            if (!myUserId) return; // Don't try to render if the user isn't logged in

            try {
                // This is the core change: Fetching the collection of decks for the current user
                const snapshot = await db.collection('users').doc(myUserId).collection('decks').get();

                snapshot.forEach(doc => {
                    const deckName = doc.id; // In our new structure, the document ID is the deck name
                    const deckContainer = document.createElement('div');
                    deckContainer.className = 'flex justify-between items-center bg-gray-800 p-2 rounded';

                    const loadBtn = document.createElement('button');
                    loadBtn.textContent = deckName;
                    loadBtn.className = 'text-left flex-grow hover:text-indigo-400';
                    loadBtn.onclick = () => loadDeck(deckName, doc.data()); // Pass the data directly

                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.className = 'bg-red-600 text-xs px-2 py-1 rounded';
                    deleteBtn.onclick = () => deleteDeck(deckName);

                    deckContainer.appendChild(loadBtn);
                    deckContainer.appendChild(deleteBtn);
                    savedDecksEl.appendChild(deckContainer);
                });
            } catch (error) {
                console.error("Error loading saved decks:", error);
                showMessage("Could not load saved decks from the cloud.", true);
            }
        };

        // --- CORE LOGIC (Firebase) ---
        async function loadAllCardsFromFirebase() {
            try {
                const snapshot = await db.collection('users').doc(myUserId).collection('cards').get();
                allCards = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderCollection();
                console.log(`Loaded ${allCards.length} cards from Firestore.`);
            } catch (error) {
                console.error("Error loading cards from Firestore: ", error);
                showMessage("Could not load card collection from the cloud.");
            }
        }

        const isBasicLand = (cardName, cardType) => {
            if (cardType !== 'Land') return false;
            const basicLandNames = ['plains', 'island', 'swamp', 'mountain', 'forest'];
            const lowerCaseName = cardName.toLowerCase();
            return basicLandNames.some(name => lowerCaseName === name || lowerCaseName === `snow-covered ${name}`);
        };

        const handleSaveCard = async () => {
            hideMessage();
            saveCardBtn.disabled = true;

            const name = document.getElementById('cardName').value.trim();
            const type = document.getElementById('cardType').value;
            const imageFile = document.getElementById('cardImage').files[0];
            const power = document.getElementById('power').value;
            const toughness = document.getElementById('toughness').value;

            if (!name || !type) {
                showMessage('Card Name and Type are required.');
                saveCardBtn.disabled = false;
                return;
            }
            if (type === 'Creature' && (!power || !toughness)) {
                showMessage('Power and Toughness are required for Creatures.');
                saveCardBtn.disabled = false;
                return;
            }

            if (!editingCardId && !isBasicLand(name, type)) {
                const isDuplicate = allCards.some(card => card.name.toLowerCase() === name.toLowerCase());
                if (isDuplicate) {
                    showMessage(`A card named "${name}" already exists in your collection. Basic lands are an exception.`);
                    saveCardBtn.disabled = false;
                    return;
                }
            }


            saveCardBtn.textContent = "Saving...";
            
            try {
                let imageUrl;
                const cardDataToSave = {
                    name, type,
                    source: 'custom',
                    subtype: document.getElementById('cardSubtype').value.trim(),
                    cost: document.getElementById('manaCost').value.trim(),
                    text: document.getElementById('cardText').value.trim(),
                    flavourText: document.getElementById('cardFlavourText').value.trim(),
                    power: type === 'Creature' ? power : null,
                    toughness: type === 'Creature' ? toughness : null,
                    loyalty: type === 'Planeswalker' ? document.getElementById('loyalty').value : null,
                };

                if (imageFile) {
                    const imageRef = storage.ref(`card-images/${Date.now()}-${imageFile.name}`);
                    const uploadTask = await imageRef.put(imageFile);
                    imageUrl = await uploadTask.ref.getDownloadURL();
                    cardDataToSave.imageUrl = imageUrl;
                }

                if (editingCardId) {
                    const cardRef = db.collection('users').doc(myUserId).collection('cards').doc(editingCardId);
                    await cardRef.update(cardDataToSave);
                    
                    const cardIndex = allCards.findIndex(c => c.id === editingCardId);
                    if(cardIndex > -1) {
                        if (!cardDataToSave.imageUrl) {
                            cardDataToSave.imageUrl = allCards[cardIndex].imageUrl;
                        }
                        allCards[cardIndex] = { ...allCards[cardIndex], ...cardDataToSave };
                    }
                    showMessage(`Success: "${name}" was updated.`, false);
                } else {
                    cardDataToSave.imageUrl = imageUrl || null;
                    // This now points to the user's private 'cards' collection
                    // This now points to the user's private 'cards' collection
                    const docRef = await db.collection('users').doc(myUserId).collection('cards').add(cardDataToSave);
                    allCards.push({ id: docRef.id, ...cardDataToSave });
                    showMessage(`Success: "${name}" was added.`, false);
                }
                
                renderCollection();
                resetForm();

            } catch (error) {
                console.error("Error saving card: ", error);
                showMessage("Failed to save card. Check console for details.");
            } finally {
                saveCardBtn.disabled = false;
            }
        };

        const deleteCard = async (cardId) => {
            const cardToDelete = allCards.find(c => c.id === cardId);
            if (!cardToDelete || !myUserId) return;

            try {
                // Find all decks that contain the card to be deleted.
                const decksRef = db.collection('users').doc(myUserId).collection('decks');
                const querySnapshot = await decksRef.where('cardIds', 'array-contains', cardId).get();
                
                const decksContainingCard = [];
                querySnapshot.forEach(doc => {
                    decksContainingCard.push(doc.id);
                });

                let confirmMessage = `Are you sure you want to permanently delete "${cardToDelete.name}"?`;
                if (decksContainingCard.length > 0) {
                    confirmMessage += `\n\nWarning: This card is in the following saved decks: ${decksContainingCard.join(', ')}. Deleting it will remove it from these decks.`;
                }

                if (!confirm(confirmMessage)) {
                    return;
                }

                // Delete the card image from storage if it exists
                if (cardToDelete.imageUrl && cardToDelete.imageUrl.includes('firebasestorage.googleapis.com')) {
                    const imageRef = storage.refFromURL(cardToDelete.imageUrl);
                    await imageRef.delete();
                }

                // Delete the card document from the user's private collection
                await db.collection('users').doc(myUserId).collection('cards').doc(cardId).delete();

                // If the card was in any decks, remove it from them
                if (decksContainingCard.length > 0) {
                    const batch = db.batch();
                    querySnapshot.forEach(doc => {
                        const deckRef = doc.ref;
                        const deckData = doc.data();
                        const newCardIds = deckData.cardIds.filter(id => id !== cardId);
                        const newCommanderIds = (deckData.commanderIds || []).filter(id => id !== cardId);
                        batch.update(deckRef, { cardIds: newCardIds, commanderIds: newCommanderIds });
                    });
                    await batch.commit();
                }
                
                // Update the UI
                allCards = allCards.filter(c => c.id !== cardId);
                currentDeck = currentDeck.filter(c => c.id !== cardId);
                commanders = commanders.filter(c => c.id !== cardId);
                renderCollection();
                renderDeckList();
                await renderSavedDecks();

                showMessage(`Successfully deleted "${cardToDelete.name}".`, false);

            } catch (error) {
                console.error("Error deleting card:", error);
                showMessage("Failed to delete card. Check console for details.", true);
            }
        };

        //Hand deleting multiple cards
        const handleDeleteSelected = async () => {
            if (selectedCards.size === 0) {
                showMessage("No cards selected to delete.", true);
                return;
            }

            if (!confirm(`Are you sure you want to permanently delete ${selectedCards.size} selected cards? This action cannot be undone.`)) {
                return;
            }

            try {
                const batch = db.batch();

                for (const cardId of selectedCards) {
                    // Add the card document to the batch delete
                    const cardRef = db.collection('users').doc(myUserId).collection('cards').doc(cardId);
                    batch.delete(cardRef);

                    // Check if the card has an image in Firebase Storage and add it to the delete queue
                    const cardToDelete = allCards.find(c => c.id === cardId);
                    if (cardToDelete && cardToDelete.imageUrl && cardToDelete.imageUrl.includes('firebasestorage.googleapis.com')) {
                        const imageRef = storage.refFromURL(cardToDelete.imageUrl);
                        // Note: Deleting images one by one is necessary, batching doesn't apply to storage directly
                        await imageRef.delete().catch(err => console.error("Failed to delete an image:", err));
                    }
                }

                await batch.commit(); // Commit all the document deletions at once

                // Update the local state
                allCards = allCards.filter(card => !selectedCards.has(card.id));

                showMessage(`Successfully deleted ${selectedCards.size} cards.`, false);
                toggleSelectMode(); // This will clear selection and re-render the collection

            } catch (error) {
                console.error("Error deleting selected cards:", error);
                showMessage("Failed to delete selected cards. Check console.", true);
            }
        };

        const populateFormForEdit = (cardId) => {
            const card = allCards.find(c => c.id === cardId);
            if (!card) return;

            editingCardId = cardId;
            document.getElementById('cardName').value = card.name || '';
            document.getElementById('cardType').value = card.type || 'Creature';
            document.getElementById('cardSubtype').value = card.subtype || '';
            document.getElementById('manaCost').value = card.cost || '';
            document.getElementById('cardText').value = card.text || '';
            document.getElementById('cardFlavourText').value = card.flavourText || '';
            document.getElementById('power').value = card.power || '';
            document.getElementById('toughness').value = card.toughness || '';
            document.getElementById('loyalty').value = card.loyalty || '';

            cardTypeSelect.dispatchEvent(new Event('change'));
            
            formTitleEl.textContent = `Editing: ${card.name}`;
            saveCardBtn.textContent = 'Update Card';
            cancelEditBtn.classList.remove('hidden');
            window.scrollTo({ top: 0, behavior: 'smooth' });
        };

        const resetForm = () => {
            document.getElementById('addCardForm').reset();
            editingCardId = null;
            formTitleEl.textContent = 'Create New Card';
            saveCardBtn.textContent = 'Add to Collection';
            cancelEditBtn.classList.add('hidden');
            cardTypeSelect.dispatchEvent(new Event('change'));
        };
        
        const handleCreateGame = () => {
            hideMessage();
            const playerName = document.getElementById('playerName').value.trim();
            const startingLife = parseInt(document.getElementById('gameMode').value, 10);

            if (currentDeck.length === 0) {
                showMessage("Please assemble or load a deck before starting.", true);
                return;
            }
            if (!playerName) {
                showMessage("Please enter your name before starting.", true);
                return;
            }

            const gamesRef = realdb.ref('games');
            const newGameRef = gamesRef.push(); 

            const mainDeckForGame = currentDeck.filter(card => !commanders.some(c => c.id === card.id));

            const initialGameState = {
                players: {
                    p1: {
                        uid: myUserId,
                        name: playerName,
                        deck: mainDeckForGame,
                        commander: commanders,
                        hand: [], 
                        battlefield: [], 
                        graveyard: [], 
                        exile: [],
                        life: startingLife,
                        shuffled: false
                    }
                },
                createdAt: firebase.database.ServerValue.TIMESTAMP
            };

            newGameRef.set(initialGameState).then(() => {
                const gameId = newGameRef.key;
                const inviteLink = `${window.location.origin}/game.html?gameId=${gameId}`;
                
                inviteLinkInputEl.value = inviteLink;
                enterGameBtn.onclick = () => {
                    window.location.href = `game.html?gameId=${gameId}`;
                };

                lobbyControlsEl.classList.add('hidden');
                gameCreatedSectionEl.classList.remove('hidden');
                
            }).catch(error => {
                console.error("Could not create game session: ", error);
                showMessage("Error starting game. Could not connect to the server.");
            });
        };
        
        const handleCopyLink = () => {
            inviteLinkInputEl.select();
            document.execCommand('copy');
            copyLinkBtn.textContent = 'Copied!';
            setTimeout(() => {
                copyLinkBtn.textContent = 'Copy';
            }, 2000);
        };

        const handleJoinGame = () => {
            hideMessage();
            const gameId = joinGameIdInput.value.trim();
            const playerName = document.getElementById('playerName').value.trim();

            if (currentDeck.length === 0) {
                showMessage("Please assemble or load a deck before joining.", true);
                return;
            }
            if (!playerName) {
                showMessage("Please enter your name before joining.", true);
                return;
            }
            if (!gameId) {
                showMessage("Please enter a Game ID to join.", true);
                return;
            }

            const mainDeckForGame = currentDeck.filter(card => !commanders.some(c => c.id === card.id));

            const pendingJoinData = {
                playerName: playerName,
                deck: mainDeckForGame,
                commanders: commanders
            };
            localStorage.setItem('pendingJoinData', JSON.stringify(pendingJoinData));

            window.location.href = `game.html?gameId=${gameId}`;
        };

        // --- Deck Management ---
        
        const addCardToDeck = (card) => {
            currentDeck.push(card);
            renderDeckList();
        };
        
        const removeCardFromDeck = (cardId) => {
            const index = currentDeck.findIndex(card => card.id == cardId);
            if (index > -1) {
                currentDeck.splice(index, 1);
                unsetCommander(cardId);
                renderDeckList();
            }
        };

        const setCommander = (card) => {
            if (!commanders.some(c => c.id === card.id)) {
                commanders.push(card);
                renderDeckList();
            }
        };

        const unsetCommander = (cardId) => {
            commanders = commanders.filter(c => c.id !== cardId);
            renderDeckList();
        };

        const handleSortDeck = (event) => {
            deckSortOrder = event.target.value; // Get the selected value from the dropdown
            renderDeckList(); // Re-render the deck with the new sort order
        };

        const handleClearDeck = () => {
            if (confirm("Are you sure you want to clear the current deck?")) {
                currentDeck = [];
                commanders = [];
                deckNameEl.value = ''; // Also clear the deck name input
                renderDeckList();
            }
        };

        const handleSaveDeck = async () => {
            hideMessage();
            const name = deckNameEl.value.trim();
            if (!name || currentDeck.length === 0) {
                showMessage('Please provide a deck name and add at least one card.', true);
                return;
            }
            if (!myUserId) {
                showMessage('Error: You must be logged in to save a deck.', true);
                return;
            }

            const deckData = {
                name: name,
                cardIds: currentDeck.map(c => c.id),
                commanderIds: commanders.map(c => c.id),
                createdAt: firebase.firestore.FieldValue.serverTimestamp() // Good practice to timestamp saves
            };

            try {
                // This is the core change: we are now saving to a 'decks' sub-collection
                // that lives inside a document specific to the current user.
                const deckRef = db.collection('users').doc(myUserId).collection('decks').doc(name);
                await deckRef.set(deckData);

                showMessage(`Success: Deck "${name}" has been saved!`, false);
                // We will update renderSavedDecks in the next step.
                await renderSavedDecks(); 
            } catch (error) {
                console.error("Error saving deck to Firestore:", error);
                showMessage("Failed to save deck. Please check the console.", true);
            }
        };

        const loadDeck = (name, deckData) => {
            if (deckData) {
                const cardIds = deckData.cardIds || [];
                const commanderIds = deckData.commanderIds || [];

                currentDeck = cardIds.map(id => allCards.find(card => card.id === id)).filter(Boolean);
                commanders = commanderIds.map(id => allCards.find(card => card.id === id)).filter(Boolean);

                deckNameEl.value = name;
                renderDeckList();
                showMessage(`Deck "${name}" loaded.`, false);
            }
        };

        const deleteDeck = async (name) => {
            if (!myUserId) return;
            if (!confirm(`Are you sure you want to permanently delete the deck "${name}"?`)) {
                return;
            }

            try {
                await db.collection('users').doc(myUserId).collection('decks').doc(name).delete();
                showMessage(`Successfully deleted deck "${name}".`, false);
                await renderSavedDecks(); // Re-render the list after deleting
            } catch (error) {
                console.error("Error deleting deck:", error);
                showMessage("Failed to delete deck. Please check the console.", true);
            }
        };

        const addSelectedToCurrentDeck = (cardIdSet, source) => {
            const cardSource = (source === 'import') ? fetchedCardsData : allCards;
            const idField = (source === 'import') ? 'name' : 'id';

            cardIdSet.forEach(cardId => {
                const cardToAdd = cardSource.find(c => c[idField] === cardId);
                if (cardToAdd) {
                    const finalCard = allCards.find(c => c.name === cardToAdd.name);
                    if (finalCard) currentDeck.push(finalCard);
                }
            });

            showMessage(`Added ${cardIdSet.size} cards to the deck.`, false);
            renderDeckList();

            // Close all modals and exit selection mode
            addToDeckModal.classList.add('hidden');
            if (source === 'import') closeImportReviewModal();
            else toggleSelectMode();
        };

        const openAddToDeckModal = async (source = 'collection') => {
            const cardIdSet = (source === 'import') ? importSelectedCards : selectedCards;
            if (cardIdSet.size === 0) {
                showMessage("No cards selected.", true);
                return;
            }

            deckChoiceList.innerHTML = ''; // Clear previous list

            // Temporarily hide the import modal if it's the source to fix the visual bug
            if (source === 'import') {
                importReviewModal.classList.add('hidden');
            }
            // Store the source so the close button knows what to do
            addToDeckModal.dataset.source = source;

            // --- NEW: Create checkboxes instead of buttons ---
            // Option for "Currently Assembling" deck
            deckChoiceList.innerHTML += `
                <label class="flex items-center space-x-3 p-2 rounded-md hover:bg-gray-700 cursor-pointer">
                    <input type="checkbox" value="__current" class="deck-checkbox h-5 w-5 rounded bg-gray-600 border-gray-500 text-indigo-600 focus:ring-indigo-500">
                    <span class="text-white">Currently Assembling Deck</span>
                </label>
            `;

            // Options for saved decks
            try {
                const snapshot = await db.collection('users').doc(myUserId).collection('decks').get();
                snapshot.forEach(doc => {
                    const deckName = doc.id;
                    deckChoiceList.innerHTML += `
                        <label class="flex items-center space-x-3 p-2 rounded-md hover:bg-gray-700 cursor-pointer">
                            <input type="checkbox" value="${deckName}" class="deck-checkbox h-5 w-5 rounded bg-gray-600 border-gray-500 text-indigo-600 focus:ring-indigo-500">
                            <span class="text-white">${deckName}</span>
                        </label>
                    `;
                });
            } catch (error) {
                console.error("Error fetching decks for modal:", error);
            }

            addToDeckModal.classList.remove('hidden');
        };

        const handleConfirmAddToDecks = async () => {
            const source = addToDeckModal.dataset.source || 'collection';
            const cardIdSet = (source === 'import') ? importSelectedCards : selectedCards;
            const cardSource = (source === 'import') ? fetchedCardsData : allCards;
            const idField = (source === 'import') ? 'name' : 'id';

            const selectedDecks = Array.from(deckChoiceList.querySelectorAll('.deck-checkbox:checked')).map(cb => cb.value);

            if (selectedDecks.length === 0) {
                showMessage("No destination decks were selected.", true);
                return;
            }

            const cardIdsToAdd = [];
            cardIdSet.forEach(cardId => {
                const card = cardSource.find(c => c[idField] === cardId);
                if (card) {
                    const finalCard = allCards.find(c => c.name === card.name);
                    if (finalCard) cardIdsToAdd.push(finalCard.id);
                }
            });

            if (cardIdsToAdd.length === 0) {
                showMessage("Could not find selected cards in the main collection.", true);
                return;
            }

            // Handle adding to the "Currently Assembling" deck
            if (selectedDecks.includes('__current')) {
                cardIdsToAdd.forEach(id => {
                    const cardToAdd = allCards.find(c => c.id === id);
                    if(cardToAdd) currentDeck.push(cardToAdd);
                });
                renderDeckList();
            }

            // Handle adding to saved decks
            const savedDeckNames = selectedDecks.filter(name => name !== '__current');
            if (savedDeckNames.length > 0) {
                try {
                    const batch = db.batch();
                    savedDeckNames.forEach(deckName => {
                        const deckRef = db.collection('users').doc(myUserId).collection('decks').doc(deckName);
                        batch.update(deckRef, {
                            cardIds: firebase.firestore.FieldValue.arrayUnion(...cardIdsToAdd)
                        });
                    });
                    await batch.commit();
                    await renderSavedDecks();
                } catch (error) {
                    console.error(`Error adding cards to saved decks:`, error);
                }
            }

            showMessage(`Added ${cardIdsToAdd.length} cards to ${selectedDecks.length} deck(s).`, false);

            if (source === 'import') closeImportReviewModal();
            else toggleSelectMode();
            addToDeckModal.classList.add('hidden');
        };

        // --- BULK IMPORT (CSV) LOGIC ---
        const handleImageUpload = async (event) => {
            const zipFile = event.target.files[0];
            if (!zipFile) return;

            imageUploadProgressEl.textContent = `Unzipping and uploading images...`;
            uploadedImageMap.clear();

            try {
                const jszip = new JSZip();
                const zip = await jszip.loadAsync(zipFile);
                const imageFiles = [];
                zip.forEach((relativePath, zipEntry) => {
                    if (!zipEntry.dir && (zipEntry.name.endsWith('.png') || zipEntry.name.endsWith('.jpg') || zipEntry.name.endsWith('.jpeg'))) {
                        imageFiles.push(zipEntry);
                    }
                });

                imageUploadProgressEl.textContent = `Found ${imageFiles.length} images. Uploading...`;

                const uploadPromises = imageFiles.map(file => {
                    return file.async('blob').then(blob => {
                        const imageRef = storage.ref(`card-images/${Date.now()}-${file.name}`);
                        return imageRef.put(blob).then(uploadTask => {
                            return uploadTask.ref.getDownloadURL().then(imageUrl => {
                                uploadedImageMap.set(file.name, imageUrl);
                            });
                        });
                    });
                });

                await Promise.all(uploadPromises);
                imageUploadProgressEl.textContent = `Successfully uploaded ${imageFiles.length} images. Ready for CSV import.`;
                imageUploadProgressEl.style.color = '#4ade80';
            } catch (error) {
                console.error("Error processing zip file:", error);
                imageUploadProgressEl.textContent = "An error occurred during zip processing.";
                imageUploadProgressEl.style.color = '#f87171';
            }
        };

        const handleCsvImport = (showSummaryModal = true) => {
            return new Promise(async (resolve, reject) => {
                const file = csvFileToProcess;
                if (!file) {
                    showMessage("Please select a CSV file to import.", true, 'import');
                    return reject("No file selected");
                }
                if(showSummaryModal) showMessage("Parsing CSV file...", false, 'import');

                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: async (results) => {
                        if (results.errors && results.errors.length > 0) {
                            const errorMessages = results.errors.map(e => `Row ${e.row}: ${e.message}`).join('\n');
                            showMessage(`CSV parsing failed...`, true, 'import');
                            return reject(new Error("CSV Parsing failed"));
                        }

                        const cardsToCreate = [];
                        const skippedCardNames = [];
                        const importedCardNames = [];
                        const errors = [];
                        const existingCardNames = new Set(allCards.map(c => c.name.toLowerCase()));
                        const namesInThisImport = new Set();

                        for (const row of results.data) {
                            const cardName = row['Card Name']?.trim();
                            const cardType = row['Card Type']?.trim();
                            if (!cardName || !cardType) {
                                errors.push(`Skipping row with missing Card Name or Card Type.`);
                                continue;
                            }
                            if (cardType === 'Creature' && (!row['Power'] || !row['Toughness'])) {
                                skippedCardNames.push(`${cardName} (Missing P/T)`);
                                continue;
                            }
                            const lowerCaseCardName = cardName.toLowerCase();
                            if (!isBasicLand(cardName, cardType) && (existingCardNames.has(lowerCaseCardName) || namesInThisImport.has(lowerCaseCardName))) {
                                skippedCardNames.push(`${cardName} (Duplicate)`);
                                continue; 
                            }
                            namesInThisImport.add(lowerCaseCardName);
                            const cardData = {
                                name: cardName, type: cardType, source: 'custom',
                                subtype: row['Card Subtype']?.trim() || '',
                                cost: row['Mana Cost']?.trim() || '',
                                text: row['Text Box']?.trim() || '',
                                flavourText: row['Flavour Text']?.trim() || '',
                                imageUrl: row['Image Filename']?.trim() ? (uploadedImageMap.get(row['Image Filename'].trim()) || null) : null,
                                power: row['Power']?.trim() || null,
                                toughness: row['Toughness']?.trim() || null,
                                loyalty: row['Starting Loyalty']?.trim() || null
                            };
                            cardsToCreate.push(cardData);
                            importedCardNames.push(cardName);
                        }

                        if (cardsToCreate.length > 0) {
                            try {
                                const batch = db.batch();
                                cardsToCreate.forEach(cardData => {
                                    const docRef = db.collection('users').doc(myUserId).collection('cards').doc();
                                    batch.set(docRef, cardData);
                                });
                                await batch.commit();
                                await loadAllCardsFromFirebase();
                            } catch (error) {
                                console.error("Error saving cards to Firestore:", error);
                                showMessage("An error occurred while saving new cards.", true, 'import');
                                return reject(error);
                            }
                        }

                        if (showSummaryModal) {
                            const importMessageArea = document.getElementById('import-message-area');
                            let summaryHTML = `<span>Import complete: </span>`;
                            if (importedCardNames.length > 0) {
                                summaryHTML += `<span id="show-imported-summary" class="font-bold text-green-400 cursor-pointer hover:underline">${importedCardNames.length} imported</span>`;
                            }
                            if (skippedCardNames.length > 0) {
                                summaryHTML += `, <span id="show-skipped-summary" class="font-bold text-yellow-400 cursor-pointer hover:underline">${skippedCardNames.length} skipped</span>`;
                            }
                            importMessageArea.innerHTML = summaryHTML;
                            importMessageArea.classList.remove('hidden');
                            document.getElementById('show-imported-summary')?.addEventListener('click', () => showImportSummaryModal('Successfully Imported Cards', importedCardNames));
                            document.getElementById('show-skipped-summary')?.addEventListener('click', () => showImportSummaryModal('Skipped Cards', skippedCardNames));
                        }

                        // Resolve the promise with the names of newly created cards
                        resolve(importedCardNames); 
                    },
                    error: (err) => {
                        showMessage(`Error parsing CSV file: ${err.message}.`, true, 'import');
                        reject(err);
                    }
                });
            });
        };

        const handleCsvImportAndAddToDeck = async () => {
            try {
                // Call the import function and tell it NOT to show the summary modal
                const importedCardNames = await handleCsvImport(false);

                // Clear previous selections and add the new card names
                importSelectedCards.clear();
                fetchedCardsData = allCards.filter(c => importedCardNames.includes(c.name));
                importedCardNames.forEach(name => importSelectedCards.add(name));

                // Open the "Add to Deck" modal
                openAddToDeckModal('import');
            } catch (error) {
                console.log("Import process cancelled or failed.", error);
                // Error messages are already handled by handleCsvImport
            }
        };

        // --- SCRYFALL IMPORT LOGIC ---
        function openImportReviewModal(cards) {
            importReviewContent.innerHTML = ''; // Clear previous results
            importSelectedCards.clear();
            const existingCardNames = new Set(allCards.map(c => c.name.toLowerCase()));

            cards.forEach(cardData => {
                const cardWrapper = document.createElement('div');
                cardWrapper.dataset.cardId = card.id;
                cardWrapper.className = 'card-wrapper p-2 bg-gray-700 rounded-lg flex flex-col items-center justify-between cursor-pointer transition-all border-2 border-transparent relative'; // Added relative positioning
                cardWrapper.dataset.cardId = cardData.name;

                // --- NEW: Check if card is already in collection ---
                const alreadyOwned = existingCardNames.has(cardData.name.toLowerCase());
                if (alreadyOwned) {
                    cardWrapper.classList.add('opacity-60'); // Fade the card slightly
                    const badge = document.createElement('span');
                    badge.className = 'absolute top-1 right-1 bg-indigo-500 text-white text-xs font-bold px-2 py-1 rounded-full';
                    badge.textContent = 'In Collection';
                    cardWrapper.appendChild(badge);
                }

                const img = document.createElement('img');
                img.src = cardData.imageUrl || 'https://placehold.co/100x140/2d3748/e2e8f0?text=No+Image';
                img.alt = cardData.name;
                img.className = 'card-image-sm object-cover rounded-md mb-2 pointer-events-none';

                const name = document.createElement('span');
                name.textContent = cardData.name;
                name.className = 'text-xs text-center font-semibold pointer-events-none';

                cardWrapper.appendChild(img);
                cardWrapper.appendChild(name);

                cardWrapper.addEventListener('click', () => {
                    if (importSelectedCards.has(cardData.name)) {
                        importSelectedCards.delete(cardData.name);
                        cardWrapper.classList.remove('border-blue-500');
                        cardWrapper.classList.add('border-transparent');
                    } else {
                        importSelectedCards.add(cardData.name);
                        cardWrapper.classList.remove('border-transparent');
                        cardWrapper.classList.add('border-blue-500');
                    }
                    importSelectionCountEl.textContent = `${importSelectedCards.size} cards selected`;
                });

                cardWrapper.addEventListener('mouseenter', (e) => showCardPopout(e, cardData));
                cardWrapper.addEventListener('mouseleave', hideCardPopout);
                cardWrapper.addEventListener('mousemove', moveCardPopout);

                importReviewContent.appendChild(cardWrapper);
            });

            importSelectionCountEl.textContent = '0 cards selected';
            importReviewModal.classList.remove('hidden');
        }

        function closeImportReviewModal() {
            importReviewModal.classList.add('hidden');
            importReviewContent.innerHTML = '';
            importSelectedCards.clear();
        }

        function showImportSummaryModal(title, cardNames) {
            const modal = document.getElementById('import-summary-modal');
            const titleEl = document.getElementById('import-summary-title');
            const listEl = document.getElementById('import-summary-list');

            titleEl.textContent = title;
            listEl.innerHTML = ''; // Clear previous list

            if (cardNames.length === 0) {
                listEl.innerHTML = '<li>No cards to show.</li>';
            } else {
                cardNames.forEach(name => {
                    const li = document.createElement('li');
                    li.textContent = name;
                    listEl.appendChild(li);
                });
            }
            modal.classList.remove('hidden');
        }
        
        const handleConfirmImport = async () => {
            if (importSelectedCards.size === 0) {
                showMessage("No cards selected.", true, 'scryfall');
                return;
            }

            const selectedData = fetchedCardsData.filter(card => importSelectedCards.has(card.name));

            const cardsToCreate = [];
            let skippedCount = 0;
            const existingCardNames = new Set(allCards.map(c => c.name.toLowerCase()));

            for (const cardData of selectedData) {
                if (!isBasicLand(cardData.name, cardData.type) && existingCardNames.has(cardData.name.toLowerCase())) {
                    skippedCount++;
                    continue;
                }
                cardsToCreate.push(cardData);
                existingCardNames.add(cardData.name.toLowerCase());
            }

            if (cardsToCreate.length > 0) {
                try {
                    const batch = db.batch();
                    cardsToCreate.forEach(cardData => {
                        const docRef = db.collection('users').doc(myUserId).collection('cards').doc();
                        batch.set(docRef, cardData);
                    });
                    await batch.commit();
                    await loadAllCardsFromFirebase(); // Refresh the main collection
                } catch (error) {
                    console.error("Error saving imported cards:", error);
                    showMessage("An error occurred while saving new cards.", true, 'scryfall');
                    closeImportReviewModal();
                    return;
                }
            }

            let successMessage = `Successfully added ${cardsToCreate.length} new cards to your collection!`;
            if (skippedCount > 0) {
                successMessage += ` Skipped ${skippedCount} cards you already own.`;
            }
            showMessage(successMessage, false, 'scryfall');
        };

        const handleScryfallImportAndAddToDeck = async () => {
            if (importSelectedCards.size === 0) {
                showMessage("No cards selected.", true, 'scryfall');
                return;
            }
            // First, save the cards to the collection. This will also close the review modal.
            await handleConfirmImport(); 
            // Then, after they are saved, open the modal to choose a deck.
            openAddToDeckModal('import');
        };

        async function fetchCardsFromScryfall(names) {
            const allFoundCards = [];
            const allNotFoundNames = [];
            const CHUNK_SIZE = 75;

            for (let i = 0; i < names.length; i += CHUNK_SIZE) {
                const chunk = names.slice(i, i + CHUNK_SIZE);
                showMessage(`Fetching batch ${Math.floor(i / CHUNK_SIZE) + 1}... (${i + chunk.length}/${names.length})`, false, 'scryfall');
                const identifiers = chunk.map(name => ({ name }));

                try {
                    const response = await fetch('https://api.scryfall.com/cards/collection', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ identifiers }),
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`Scryfall API Error: ${errorData.details || response.statusText}`);
                    }
                    const result = await response.json();
                    if (result.data) allFoundCards.push(...result.data);
                    if (result.not_found) allNotFoundNames.push(...result.not_found.map(item => item.name));
                } catch (error) {
                    console.error("Error fetching chunk:", error);
                    allNotFoundNames.push(...chunk);
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            return { found: allFoundCards, notFound: allNotFoundNames };
        }

        function processScryfallCard(card) {
            const cardFace = card.card_faces ? card.card_faces[0] : card;
            const [type, subtype] = (card.type_line || '').split(' â€” ');
            return {
                name: card.name,
                type: type || '',
                source: 'scryfall',
                subtype: subtype || '',
                cost: cardFace.mana_cost || '',
                text: cardFace.oracle_text || '',
                power: card.power || null,
                toughness: card.toughness || null,
                loyalty: card.loyalty || null,
                flavourText: cardFace.flavor_text || '',
                imageUrl: card.image_uris?.normal || cardFace.image_uris?.normal || null,
            };
        }

        function displayResults(found, notFound) {
            foundCardsGrid.innerHTML = '';
            notFoundList.innerHTML = '';
            foundCount.textContent = found.length;
            found.forEach(cardData => {
                const cardWrapper = document.createElement('div');
                cardWrapper.className = 'text-center';
                const img = document.createElement('img');
                img.src = cardData.imageUrl || 'https://placehold.co/100x140/2d3748/e2e8f0?text=No+Image';
                img.alt = cardData.name;
                img.className = 'card-preview-img mx-auto';
                const name = document.createElement('p');
                name.textContent = cardData.name;
                name.className = 'text-xs mt-1';
                cardWrapper.appendChild(img);
                cardWrapper.appendChild(name);
                foundCardsGrid.appendChild(cardWrapper);
            });

            notFoundCount.textContent = notFound.length;
            if (notFound.length > 0) {
                document.getElementById('notFoundSection').classList.remove('hidden');
                notFound.forEach(name => {
                    const li = document.createElement('li');
                    li.textContent = name;
                    notFoundList.appendChild(li);
                });
            } else {
                 document.getElementById('notFoundSection').classList.add('hidden');
            }
            resultsArea.classList.remove('hidden');
        }

        function convertToCSV(data) {
            if (data.length === 0) return '';
            const headers = ['Card Name', 'Card Type', 'Card Subtype', 'Mana Cost', 'Text Box', 'Flavour Text', 'Power', 'Toughness', 'Starting Loyalty', 'Image Filename', 'Commander?'];
            const rows = data.map(card => {
                const isLegendary = /Legendary/.test(card.type_line);
                const isCreature = /Creature/.test(card.type_line);
                const isCommander = isLegendary && isCreature ? 'Y' : '';
                const values = [card.name, card.type, card.subtype, card.cost, card.text, card.flavourText, card.power, card.toughness, card.loyalty, '', isCommander];
                return values.map(val => {
                    const str = String(val === null || val === undefined ? '' : val);
                    if (str.includes(',') || str.includes('"') || str.includes('\n')) return `"${str.replace(/"/g, '""')}"`;
                    return str;
                }).join(',');
            });
            return [headers.join(','), ...rows].join('\n');
        }

        function downloadCSV(csvString) {
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-s8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'scryfall_import.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        async function handleFetchClick() {
            const inputText = cardListInput.value.trim();
            if (!inputText) {
                showMessage('Please enter at least one card name.', true, 'scryfall');
                return;
            }

            fetchBtn.disabled = true;
            fetchBtn.textContent = 'Fetching...';
            statusArea.innerHTML = '';
            resultsArea.classList.add('hidden');
            downloadCsvBtn.disabled = true;
            addDirectlyBtn.disabled = true;
            fetchedCardsData = [];

            const names = [...new Set(inputText.split('\n').map(name => name.trim()).filter(Boolean))];

            try {
                const { found, notFound } = await fetchCardsFromScryfall(names);
                fetchedCardsData = found.map(processScryfallCard);
                openImportReviewModal(fetchedCardsData);
                if (fetchedCardsData.length > 0) {
                    downloadCsvBtn.disabled = false;
                    addDirectlyBtn.disabled = false;
                }
            } catch (error) {
                console.error("An error occurred during the fetch process:", error);
                showMessage('An unexpected error occurred. Check the console for details.', true, 'scryfall');
            } finally {
                fetchBtn.disabled = false;
                fetchBtn.textContent = 'Fetch Card Data';
            }
        }

        async function handleAddDirectly() {
            addDirectlyBtn.disabled = true;
            addDirectlyBtn.textContent = 'Adding...';

            const cardsToCreate = [];
            let skippedCount = 0;
            const existingCardNames = new Set(allCards.map(c => c.name.toLowerCase()));

            for (const cardData of fetchedCardsData) {
                const lowerCaseCardName = cardData.name.toLowerCase();
                 if (!isBasicLand(cardData.name, cardData.type) && existingCardNames.has(lowerCaseCardName)) {
                    skippedCount++;
                    continue; 
                }
                cardsToCreate.push(cardData);
                existingCardNames.add(lowerCaseCardName); // Add to set to prevent duplicates within the same import
            }

            if (cardsToCreate.length > 0) {
                try {
                    const batch = db.batch();
                    cardsToCreate.forEach(cardData => {
                        const docRef = db.collection('users').doc(myUserId).collection('cards').doc();
                        batch.set(docRef, cardData);
                    });
                    await batch.commit();
                    
                    let successMessage = `Successfully added ${cardsToCreate.length} new cards to your collection!`;
                    if (skippedCount > 0) successMessage += ` Skipped ${skippedCount} duplicate cards.`;
                    showMessage(successMessage, false, 'scryfall');

                    await loadAllCardsFromFirebase(); // Refresh the main collection view
                } catch (error) {
                    console.error("Error saving cards to Firestore:", error);
                    showMessage("An error occurred while saving new cards.", true, 'scryfall');
                }
            } else {
                let message = "No new cards were added.";
                if (skippedCount > 0) message += ` All ${skippedCount} fetched cards were already in your collection.`
                showMessage(message, false, 'scryfall');
            }

            addDirectlyBtn.textContent = 'Add to My Collection';
        }

        // --- INITIALIZATION ---
        async function init() {
            firebase.auth().onAuthStateChanged(async (user) => {
                if (user) {
                    myUserId = user.uid;
                    console.log("DEBUG: User signed in with UID:", myUserId);
                    try {
                        // --- ASSIGN ALL DOM ELEMENTS ---
                        cardCollectionEl = document.getElementById('cardCollection');
                        deckListEl = document.getElementById('deckList');
                        commanderListEl = document.getElementById('commanderList');
                        deckCountEl = document.getElementById('deckCount');
                        deckNameEl = document.getElementById('deckName');
                        saveDeckBtn = document.getElementById('saveDeck');
                        clearDeckBtn = document.getElementById('clearDeckBtn');
                        sortDeckSelect = document.getElementById('sortDeckSelect');
                        savedDecksEl = document.getElementById('savedDecks');
                        saveCardBtn = document.getElementById('saveCardBtn');
                        cancelEditBtn = document.getElementById('cancelEditBtn');
                        formTitleEl = document.getElementById('form-title');
                        cardTypeSelect = document.getElementById('cardType');
                        creatureFields = document.getElementById('creatureFields');
                        planeswalkerFields = document.getElementById('planeswalkerFields');
                        createGameBtn = document.getElementById('createGameBtn');
                        joinGameBtn = document.getElementById('joinGameBtn');
                        joinGameIdInput = document.getElementById('joinGameIdInput');
                        messageAreaEl = document.getElementById('message-area');
                        importCsvBtn = document.getElementById('importCsvBtn');
                        importAndAddBtn = document.getElementById('importAndAddBtn'); 
                        imageUploadProgressEl = document.getElementById('image-upload-progress');
                        lobbySectionEl = document.getElementById('lobby-section');
                        lobbyControlsEl = document.getElementById('lobby-controls');
                        gameCreatedSectionEl = document.getElementById('game-created-section');
                        inviteLinkInputEl = document.getElementById('inviteLinkInput');
                        copyLinkBtn = document.getElementById('copyLinkBtn');
                        enterGameBtn = document.getElementById('enterGameBtn');
                        cardListInput = document.getElementById('cardListInput');
                        fetchBtn = document.getElementById('fetchBtn');
                        statusArea = document.getElementById('statusArea');
                        resultsArea = document.getElementById('resultsArea');
                        foundCardsGrid = document.getElementById('foundCardsGrid');
                        notFoundList = document.getElementById('notFoundList');
                        foundCount = document.getElementById('foundCount');
                        notFoundCount = document.getElementById('notFoundCount');
                        downloadCsvBtn = document.getElementById('downloadCsvBtn');
                        addDirectlyBtn = document.getElementById('addDirectlyBtn');
                        importReviewModal = document.getElementById('import-review-modal');
                        importReviewClose = document.getElementById('import-review-close');
                        document.getElementById('import-summary-close-btn').addEventListener('click', () => {
                            document.getElementById('import-summary-modal').classList.add('hidden');
                        });
                        importSelectAllBtn = document.getElementById('import-select-all-btn');
                        importDeselectAllBtn = document.getElementById('import-deselect-all-btn');
                        importSelectionCountEl = document.getElementById('import-selection-count');
                        importReviewContent = document.getElementById('import-review-content');
                        importReviewCancel = document.getElementById('import-review-cancel');
                        importReviewConfirm = document.getElementById('import-review-confirm');
                        importReviewAddToDeckBtn = document.getElementById('import-review-add-to-deck');
                        filterNameInput = document.getElementById('filterName');
                        filterTypeSelect = document.getElementById('filterType');
                        filterSortSelect = document.getElementById('filterSort');
                        filterColorSelect = document.getElementById('filterColor');
                        filterSourceSelect = document.getElementById('filterSource');
                        prevPageBtn = document.getElementById('prev-page-btn');
                        nextPageBtn = document.getElementById('next-page-btn');
                        pageInfoEl = document.getElementById('page-info');
                        toggleSelectModeBtn = document.getElementById('toggle-select-mode-btn');
                        selectionActionBar = document.getElementById('selection-action-bar');
                        selectionCountEl = document.getElementById('selection-count');
                        deleteSelectedBtn = document.getElementById('delete-selected-btn');
                        addSelectedToDeckBtn = document.getElementById('add-selected-to-deck-btn');
                        selectAllBtn = document.getElementById('select-all-btn');
                        deselectAllBtn = document.getElementById('deselect-all-btn');
                        cardPopoutEl = document.getElementById('card-popout');
                        popoutNameEl = document.getElementById('popout-name');
                        popoutCostEl = document.getElementById('popout-cost');
                        popoutImgEl = document.getElementById('popout-img');
                        popoutTypeEl = document.getElementById('popout-type');
                        popoutPtEl = document.getElementById('popout-pt');
                        popoutTextEl = document.getElementById('popout-text');
                        popoutFlavourEl = document.getElementById('popout-flavour');
                        addToDeckModal = document.getElementById('add-to-deck-modal');
                        addToDeckCloseBtn = document.getElementById('add-to-deck-close-btn');
                        deckChoiceList = document.getElementById('deck-choice-list');
                        addToDeckConfirmBtn = document.getElementById('add-to-deck-confirm-btn');
                        gridViewBtn = document.getElementById('grid-view-btn');
                        listViewBtn = document.getElementById('list-view-btn');
                        manaValueOperator = document.getElementById('manaValueOperator');
                        manaValueFilter = document.getElementById('manaValueFilter');
                        jumpToPageInput = document.getElementById('jump-to-page-input');
                        cardsPerPageSelect = document.getElementById('cards-per-page-select');

                        // --- ATTACH ALL EVENT LISTENERS ---
                        const tabBtns = document.querySelectorAll('.tab-button');
                        const tabContents = document.querySelectorAll('.tab-content');
                        tabBtns.forEach(btn => {
                            btn.addEventListener('click', () => {
                                tabBtns.forEach(b => b.classList.remove('active'));
                                btn.classList.add('active');
                                const targetId = btn.id.replace('btn', 'content');
                                tabContents.forEach(content => {
                                    content.classList.remove('active');
                                    if (content.id === targetId) {
                                        content.classList.add('active');
                                    }
                                });
                            });
                        });
                        cardTypeSelect.addEventListener('change', () => {
                            const selectedType = cardTypeSelect.value;
                            creatureFields.classList.toggle('hidden', selectedType !== 'Creature');
                            planeswalkerFields.classList.toggle('hidden', selectedType !== 'Planeswalker');
                        });

                        gridViewBtn.addEventListener('click', () => {
                            if (currentView === 'list') {
                                currentView = 'grid';
                                gridViewBtn.classList.add('bg-indigo-600', 'text-white');
                                gridViewBtn.classList.remove('bg-gray-700', 'text-gray-400', 'hover:bg-gray-600');
                                listViewBtn.classList.add('bg-gray-700', 'text-gray-400', 'hover:bg-gray-600');
                                listViewBtn.classList.remove('bg-indigo-600', 'text-white');
                                renderFilteredCollection();
                            }
                        });

                        listViewBtn.addEventListener('click', () => {
                            if (currentView === 'grid') {
                                currentView = 'list';
                                listViewBtn.classList.add('bg-indigo-600', 'text-white');
                                listViewBtn.classList.remove('bg-gray-700', 'text-gray-400', 'hover:bg-gray-600');
                                gridViewBtn.classList.add('bg-gray-700', 'text-gray-400', 'hover:bg-gray-600');
                                gridViewBtn.classList.remove('bg-indigo-600', 'text-white');
                                renderFilteredCollection();
                            }
                        });

                        saveCardBtn.addEventListener('click', handleSaveCard);
                        cancelEditBtn.addEventListener('click', resetForm);
                        saveDeckBtn.addEventListener('click', handleSaveDeck);
                        clearDeckBtn.addEventListener('click', handleClearDeck);
                        sortDeckSelect.addEventListener('change', handleSortDeck);
                        createGameBtn.addEventListener('click', handleCreateGame);
                        joinGameBtn.addEventListener('click', handleJoinGame);
                        copyLinkBtn.addEventListener('click', handleCopyLink);
                        document.getElementById('bulkImageUpload').addEventListener('change', handleImageUpload);
                        document.getElementById('csvFile').addEventListener('change', (event) => {
                            if (event.target.files && event.target.files.length > 0) {
                                csvFileToProcess = event.target.files[0];
                            }
                        });
                        importCsvBtn.addEventListener('click', () => handleCsvImport(true));
                        importAndAddBtn.addEventListener('click', handleCsvImportAndAddToDeck); // ADD THIS LINE
                        fetchBtn.addEventListener('click', handleFetchClick);
                        downloadCsvBtn.addEventListener('click', () => {
                            const csv = convertToCSV(fetchedCardsData);
                            downloadCSV(csv);
                        });
                        addDirectlyBtn.addEventListener('click', handleAddDirectly);
                        filterNameInput.addEventListener('input', renderFilteredCollection);
                        filterTypeSelect.addEventListener('change', renderFilteredCollection);
                        filterSortSelect.addEventListener('change', renderFilteredCollection);
                        filterColorSelect.addEventListener('change', renderFilteredCollection);
                        filterSourceSelect.addEventListener('change', renderFilteredCollection);
                        manaValueOperator.addEventListener('change', renderFilteredCollection);
                        manaValueFilter.addEventListener('input', renderFilteredCollection);
                        prevPageBtn.addEventListener('click', () => {
                            if (currentPage > 1) {
                                currentPage--;
                                renderFilteredCollection();
                            }
                        });
                        nextPageBtn.addEventListener('click', () => {
                            currentPage++;
                            renderFilteredCollection();
                        });
                        jumpToPageInput.addEventListener('change', handleJumpToPage);
                        cardsPerPageSelect.addEventListener('change', handlePerPageChange);
                        toggleSelectModeBtn.addEventListener('click', toggleSelectMode);
                        deleteSelectedBtn.addEventListener('click', handleDeleteSelected);
                        addSelectedToDeckBtn.addEventListener('click', () => openAddToDeckModal('collection'));
                        selectAllBtn.addEventListener('click', handleSelectAllOnPage);
                        deselectAllBtn.addEventListener('click', handleDeselectAll);
                        addToDeckCloseBtn.addEventListener('click', () => {
                            addToDeckModal.classList.add('hidden');
                            if (addToDeckModal.dataset.source === 'import') {
                                importReviewModal.classList.remove('hidden');
                            }
                        });
                        importReviewClose.addEventListener('click', closeImportReviewModal);
                        importReviewCancel.addEventListener('click', closeImportReviewModal);
                        importReviewConfirm.addEventListener('click', handleConfirmImport);
                        importReviewAddToDeckBtn.addEventListener('click', handleScryfallImportAndAddToDeck);
                        importSelectAllBtn.addEventListener('click', () => {
                            importReviewContent.querySelectorAll('.card-wrapper').forEach(wrapper => {
                                if (!importSelectedCards.has(wrapper.dataset.cardId)) {
                                    wrapper.click();
                                }
                            });
                        });
                        importDeselectAllBtn.addEventListener('click', () => {
                            importReviewContent.querySelectorAll('.card-wrapper').forEach(wrapper => {
                                if (importSelectedCards.has(wrapper.dataset.cardId)) {
                                    wrapper.click();
                                }
                            });
                        });

                        addToDeckConfirmBtn.addEventListener('click', handleConfirmAddToDecks);

                        // --- INITIAL LOAD ---
                        await loadAllCardsFromFirebase();
                        await renderSavedDecks();
                        cardTypeSelect.dispatchEvent(new Event('change'));

                    } catch (error) {
                        console.error("Initialization failed:", error);
                        document.body.innerHTML = `<div class="text-red-400 p-8">Could not connect to the server. Please check the console and refresh the page. Error: ${error.message}</div>`;
                    }
                } else {
                    window.location.href = 'index.html';
                }
            });
        }

        init();
    </script>
</body>
</html>
